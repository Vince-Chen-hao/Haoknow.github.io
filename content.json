{"meta":{"title":"Vince Blog","subtitle":"一個抒發本人心情的地方","description":"","author":"Vince","url":"https://vince-chen-hao.github.io/KnowHao","root":"/"},"pages":[],"posts":[{"title":"Hello World","slug":"hello-world","date":"2020-05-12T16:00:00.000Z","updated":"2020-05-13T08:22:34.618Z","comments":true,"path":"2020/05/13/hello-world/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2020/05/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"前端文","slug":"前端文","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/%E5%89%8D%E7%AB%AF%E6%96%87/"},{"name":"教學文","slug":"教學文","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/%E6%95%99%E5%AD%B8%E6%96%87/"}]},{"title":"JS- scope chain","slug":"0513","date":"2020-05-11T16:00:00.000Z","updated":"2020-05-14T03:32:55.637Z","comments":true,"path":"2020/05/12/0513/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2020/05/12/0513/","excerpt":"","text":"外部環境參照 More info: Generating","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/JavaScript/"}]},{"title":"Vue_ MVVM架構說明","slug":"0116","date":"2020-05-11T16:00:00.000Z","updated":"2020-05-14T08:46:21.341Z","comments":true,"path":"2020/05/12/0116/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2020/05/12/0116/","excerpt":"","text":"MVVM 是Model-View-ViewModel 的縮寫，它是一種基於前端開發的架構模式，其核心是提供對View 和View Model 的雙向數據綁定，這使得View Model的狀態改變可以自動傳遞給View，這就是所謂的數據雙向綁定。注意Vue非MVVM框架，但MVVM概念影響Vue.js的運作。 MVVM 圖解 透過ViewModel將view及model做串連綁定，因此透過在view的變更，後端的資料也會同步更新數值，相較於jQ需寫程式碼去重新匯入view及改變資料的狀態，較為多工，並且需操作畫面上的dom元素， 而Vue是以資料狀態操作畫面 透過DOM裡面的監聽event來控制/影響View Model，然後去修改Model中的資料內容; 當Model中的資料變更，會讓View Model知道，再去修改相對應DOM中的內容","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/Vue/"}]},{"title":"ES6_let、const變數","slug":"0203","date":"2020-02-02T16:00:00.000Z","updated":"2020-05-14T11:17:28.080Z","comments":true,"path":"2020/02/03/0203/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2020/02/03/0203/","excerpt":"","text":"ES6的變異總體而言，使用 let 與 const 的變數宣告方式，相較於 var 會更為嚴謹，因此建議在開發 ES6 之後的專案，使用let 與 const 作為變數宣吿，除了讓專案更穩定之外，也可以增加程式碼的可讀性。以下三點解釋： 區塊限制使用 變數「不」提升(hositing) 不允許重複宣告 案例1：let與const是用來宣告區塊裡的變數＊區塊是指程式碼{}的部分。 123456&lt;script&gt; if(2&gt;1)&#123; let a =3 &#125;&lt;/script&gt; 案例2：比較let與Var的差異12345678910var a = 3;var a = 5;//結果會等於5let a = 3;let a = 5;//結果顯示錯誤，因重複宣告變數 var變數會向上提升，如果沒有命名變數也會顯示undefined，而let與const則不會 同個區塊不可重複命名 常數const: 裝入東西(值)之後就上鎖的盒子，之後不可以再更動裡面的值，const 是唯獨變數，不能被修改，當重要檔案不能被變更如url網址，就適合使用唯獨變數。但如果是在陣列[]或者物件{}內仍可以被變更 變數let: 暫時存放值的盒子，盒子是打開的，可以更動裡面的值 let與var的作用域：作用域不一樣，var的作用域在函數 (function) 裡，let的作用域則是在區塊 (block) 裡。 全域變數：在函式作用域(function scope)之外宣告的變數，全域變數在整個程式中都可以被存取與修改。 區域變數：在函式作用域(function scope)內宣告，每次執行函式時，就會建立區域變數再予以摧毀，而且函式之外的所有程式碼都不能存取這個變數。 使用var宣告變數，可用範圍以function為界，function外讀不到值，但如使用區塊語句像if, else, for, while等等區塊語句時，宣告的區域變數仍然可在整段程式碼做存取，這並不是我們希望的結果，這時候就會建議使用let宣告。","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/ES6/"}]},{"title":"Webpack_建置工具","slug":"0202","date":"2020-02-01T16:00:00.000Z","updated":"2020-05-14T10:29:23.797Z","comments":true,"path":"2020/02/02/0202/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2020/02/02/0202/","excerpt":"","text":"介紹建置工具過去：早期前端工程師寫網頁，僅透過前端三大元素「JavaScript、CSS、HTML」開發web應用。 現今：近年前端發展出許多新思維，出現了「模組化」的概念、「新框架」的出現、「新語言」的誕生，讓傳統的作法不再流行，各種可以加強開發效率的新工具出現。 模組化：模組化是將一個複雜的系統，分解為多個模組以方便程式開發。例：ES6模組化是國際標準組織ECMA提出的JavaScript模組化標準，他在語言層面上實現模組化，成為瀏覽器和伺服器通用的模組化解決方案。 新框架：在web應用變的龐大時，直接操作DOM會使程式變得複雜難以維護，因此出現React、Vue、Augular前端框架。 新語言：ES6、TypeScript、Flow、SCSS… 然而，前端技術發展之快，卻有一個共同點：這些工具的原始碼無法直接執行，必須透過「轉換」才可以正常執行，因此，「建置工具」就誕生了。 建置工具實際任務「建置」就是將原始程式碼，轉換成可以執行的JavaScript、CSS、HTML。「建置」的目的最主要就是工程化、自動化。 程式轉換：將TypeScript編譯為JavaScript，將SCSS編譯為CSS。 檔案最佳化：壓縮JavaScript、CSS、HTML程式，壓縮合併圖片。 程式分割：分析首頁不需要執行的部分程式，讓其非同步載入。 模組合併：採用模組化建置的專案中的有多個模組、檔案，透過建置功能，將模組合併為一個檔案。 自動更新：監聽本機端程式碼的變動，自動重新建置、更新瀏覽器。 程式驗證：在程式被傳送到倉庫前，需要驗證程式是否符合標準，以及單元測試是否通過。 自動發布：更新程式後，自動建置出現上發布程式，並傳輸給發布系統。 常見的「建置工具」Npm Script：Node.js附帶的套件管理員Grunt：自動化執行依賴的工作Gulp：以串流為基礎的自動化建置工Fis3：整合各種Web開發需要的建置功能Webpack：包裝模組化JavaScript的工具Rollup：專注於ES6的模組包裝工具 Webpack為何物在Webpack裡的所有檔案皆被視為模組，透過Loader轉換檔案，透過Plugin植入鉤子，最後輸出為一個由「多個模組合成的檔案」。所以一個專案中的所有檔案，包含JavaScript、CSS、SCSS、圖片、範本，在經過Webpack的處理，最後會輸出為瀏覽器可以使用的靜態資源。 webpack幫我們做的事情很簡單，就是幫我們編譯我們的Preprocess成瀏覽器看得懂的內容然後打包成一包的完成檔案然後拿去server上傳上去。 webpack 把「任何資源」都視成一個模組。圖片是模組，所以你可以 import Image from ‘./assets/banner.png’；CSS 是模組，你可以 import styles from’style.css’，只要是任何資源都可以 import 進來使用。 使用模組化，避免載入順序引發錯誤的訊息 如使用框架開發，如Vue、react，仍建議使用原框架的CLI 相依性高才建議使用webpack模組化，例如在開發SPA就很適用，則js都是獨立時不太建議使用。 Webpack安裝方式請參考Mike影片有詳盡解說","categories":[],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/Webpack/"}]},{"title":"Vue_ 解析Props、 emit","slug":"0129","date":"2020-01-28T16:00:00.000Z","updated":"2020-05-14T10:41:51.385Z","comments":true,"path":"2020/01/29/0129/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2020/01/29/0129/","excerpt":"","text":"vue 組件，會使用 props 來接受上層傳來的資料。props 是一個陣列，裡面包含多個字串。將原本在底下新增的元件移置到新的vue頁面上，原本的執行方式是在html裡頭加上的元件，就能顯示出新vue上的功能，而要顯示此功能就需要進行串接的動作，在新的vue元件裡，需要先命名一變數，當主頁面或其他頁面要使用此元件時，只需要完成變數間串接便可使用 Props用法命名上，假設在 component 中的 props 使用 camelCase、Pascalcase，在 html 模板中引用時，一律使用 kebab-case ，因為會需要先經過瀏覽器解析。 前提是因為元件屬於內層，vue的主頁面是外層，當要從外層傳入內層需要使用Props語法，將元件裡的變數載入，再到html裡做指定的更換，才能將外層的元素(data內資料)載入到元件內，完成串接props: [‘pageProps’], 主頁面串接範例如下： &lt;Pagination :pageprops=\"pagination\" &gt;&lt;/Pagination&gt; *pagination是data裡的變數 總結：在元件內層裡的公式都需要一個變數x，而在主頁面裡取用需要執行的變數A，將此變數名稱A替換變數x的位置(串接完成)，A變數就會到元件內層進行功能渲染，將渲染的成果在主頁面裡自動呈現，以完成的元件的使用。 emit用法此用法則是內層去觸發外層的函式，例如在點擊時舊會使用到，當我們在內層進行元件的編寫時，不僅只使用v-model概念的變數props串接，也會有觸發事件產生(大部分)，因此就會使用emit去觸發主頁面的methods函式內容。 methods: { pageEmit(page) { this.$emit(\"pagenum_emit\", page); } } 在元件內層同樣要在script寫上methods，並需要一個變數y，以上面的例子來看y等同於pageEmit代參數，執行emit語法再更換一組變數z，此變數z就會到主頁面去跟需觸發的事件做串接(更換對應的變數名稱) 主頁面串接如下： &lt;Pagination @pagenum_emit=\"getProducts\"&gt;&lt;/Pagination&gt; *getProducts是函式名稱*注意在html裡要有大小駝峰的用法，建議使用get_products","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/Vue/"}]},{"title":"Vue_ 元件Component","slug":"0128","date":"2020-01-27T16:00:00.000Z","updated":"2020-05-14T09:06:25.955Z","comments":true,"path":"2020/01/28/0128/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2020/01/28/0128/","excerpt":"","text":"定義Vue 應用程式的使用，主要是以 Vue component 元件 所組成，而最上層是以 Root 為主，下面包含 Header, Content 與 side （不同的 component ）。而每個 Component 當中的 data 都會是互相獨立的，使用前端框架的好處在於，很多時候同樣重複的事情，你只需要做一次，就能重複使用，並且在後面的維護上更為方便。 首先用Vue.component()方法 第一個參數是component的名字(component 命名用全小寫以 dash 分隔) 第二個參數是一個物件，其中用 templete 的字串定義組件的視覺元素(直接定義html的內容) 重點！ component的宣告必須在 vue 實例 new之前！ 原寫法(無使用元件)123456789101112131415&lt;body&gt; &lt;div id=\"app\"&gt; &lt;button @click=\"count++\"&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt; &lt;/div&gt; &lt;/body&gt;var app = new Vue(&#123; el: '#app', data: &#123; count: 0 &#125;&#125;); 元件寫法123456789101112131415161718&lt;body&gt; &lt;div id=\"app\"&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;/div&gt; &lt;/body&gt;Vue.component('button-counter', &#123; data: function () &#123; return &#123; count: 0 &#125; &#125;, template: '&lt;button v-on:click=\"count++\"&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;'&#125;) x-template使用時機若是 template 中的語法太過複雜，會使用 x-template 的方式來改善程式的可讀性。 x-template 的宣告必須在另一個 script元素中，並為其帶上 text/x-template 的類型，然後通過一個 id 將模板引用過去。 123456789101112&lt;script type=\"text/x-template\" id=\"rowCompTemp\"&gt; &lt;tr&gt; &lt;td&gt;&#123;‌&#123; person.name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;‌&#123; person.cash &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;‌&#123; person.icash &#125;&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/script&gt;Vue.component('row-comp', &#123; props: ['person'], template: '#rowCompTemp'&#125;) 元件使用方式（全域、區域註冊）Global 全域註冊如果有元件共用的需求，我們會使用Vue.component 語法來註冊一個元件，在註冊全域元件時要給予兩個參數，分別為「組件名稱」及「選項物件」，在下方範例中「組件名稱」為 component-layout ，「選項物件」則為其後的內容。 不過使用全域註冊的缺點是，不管有沒有使用到這個元件，其元件就一定會載入，因此，使用全域註冊會將原本不需要的組件載入進來，整體而言，會拖慢網頁載入的時間。 12345678910111213141516171819&lt;div id=”app”&gt; &lt;component-layout&gt;&lt;/component-layout&gt;&lt;/div&gt;&lt;script&gt;Vue.component(\"component-layout\", &#123; template: `&lt;div&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt;`, data()&#123; return&#123; text:'我是全域註冊' &#125; &#125;&#125;);let vm = new Vue(&#123; el: \"#app\"&#125;);&lt;script&gt; Local 局部註冊如同前面所提，考量全域註冊的缺點，某些特定元件就會用區域註冊的方式，註冊在需要使用它的元件之中，同時，它是一個選項物件，可以由 components 這個選項物件屬性載入 Vue 實例 使用。 123456789101112131415161718192021&lt;div id=”app”&gt; &lt;component-layout&gt;&lt;/component-layout&gt;&lt;/div&gt;&lt;script&gt;let vm = new Vue(&#123; el: \"#app\", components:&#123; 'component-layout' :&#123; template: `&lt;div&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt;`, data()&#123; return &#123; text:'我是局部註冊' &#125; &#125; &#125; &#125;&#125;);&lt;script&gt;","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/Vue/"}]},{"title":"Vue_生命週期","slug":"0125","date":"2020-01-24T16:00:00.000Z","updated":"2020-05-14T09:22:37.186Z","comments":true,"path":"2020/01/25/0125/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2020/01/25/0125/","excerpt":"","text":"第一階段：Creation 初始建置Creation 階段是組件中運行的第一個 Hook 函式，與其他階段不同，它是在伺服器端渲染期間運行。因此，若需要在客戶端渲染和伺服器渲染期間於元件當中設置事件，須於此階段進行設定。 beforeCreate：Vue實例 初始化。 created：Vue實例 建立完成。資料 $data 已可取得，但 $el 屬性尚未被建立。 第二階段：Mounting 資料掛載接續上一個 Creation 階段，首先他會先判斷是否有無 $el 屬性，若沒有則會嘗試另一種掛載方式（使用$mount掛載el）。再來會判斷是否有 $template 屬性 ，若有則直接使用 render function ，反之則使用 $el teamplate 進行模板編譯。 beforeMount：執行元素掛載之前，代表 $el 尚未被建立。 mounted：元素已掛載， $el 被建立，是最常使用的生命週期 hook 補充：若要操作 AJAX，須於 created Hook階段後才能使用，但通常到 mounted Hook 階段，也就是現在才會被使用，屆時，也代表資料已掛載成功。 第三階段：Updating 重新渲染畫面當元件的資料屬性發生變動，或其他因素導致畫面需要重新渲染時，則會調用 Updating 刷新網頁內容。 beforeUpdate：當資料改變被呼叫使用，還不會渲染 View。 updated：當資料更新完成，則驅動 DOM 元素重新渲染畫面 View。 第四階段：Destruction 銷毀當呼叫 destroy 函式時，則會執行銷毀的動作，將原始的元件從 DOM 元素中移除。 beforeDestroy：Vue實例還可使用。 destroyed：Vue實例銷毀，所有的DOM 元素綁定被解除、移除偵聽事件、Vue child 實例也被一併銷毀。","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/Vue/"}]},{"title":"Git_分支","slug":"0122","date":"2020-01-21T16:00:00.000Z","updated":"2020-05-14T09:36:25.290Z","comments":true,"path":"2020/01/22/0122/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2020/01/22/0122/","excerpt":"","text":"分支建立(git branch)分支的好處，就是每一條線都各司其職，做完事後，再將兩條線的功能合併，並部署上線。 原狀態 新增分支接下來，我們想要開始新增新功能，但又不能污染到目前 master 的穩定版本狀態，於是我們新增一個 dev 分支，指令是：git branch dev 切換至分支當我們要切換分支時，指令是：git checkout dev 新增分支上commit再來我們就開始在 dev 上開發，並新增兩個commit。 切換回主狀態接下來我們切換回 master 看它的狀態。指令是：git checkout master &lt;重要&gt;合併分支：讓master吃到dev最新狀態我們目前的狀態是 master 目前的版本比較舊，而 dev 的版本比較新，所以接下來我們要做的事情，就是讓 master 可以吃到 c3、c4 的 commit。 因為目前 master 版本比較舊，你就必須先用 git checkout master 指令，讓 HEAD 移動到 master。 確保有切換後，就可以下此指令：git merge dev此時，master 位置就會在 c4 了。 快轉模式 vs 非快轉模式當你的 HEAD 位置是某個要被 merge branch(dev) 上的初始 commit，就會觸發快轉模式。 但如果在 master 再新增一個 commit 的話，就不會觸發快轉模式。","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/Git/"}]},{"title":"Git_分支","slug":"0219","date":"2020-01-21T16:00:00.000Z","updated":"2020-05-14T10:15:38.406Z","comments":true,"path":"2020/01/22/0219/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2020/01/22/0219/","excerpt":"","text":"分支建立(git branch)分支的好處，就是每一條線都各司其職，做完事後，再將兩條線的功能合併，並部署上線。 原狀態 新增分支接下來，我們想要開始新增新功能，但又不能污染到目前 master 的穩定版本狀態，於是我們新增一個 dev 分支，指令是：git branch dev 切換至分支當我們要切換分支時，指令是：git checkout dev 新增分支上commit再來我們就開始在 dev 上開發，並新增兩個commit。 切換回主狀態接下來我們切換回 master 看它的狀態。指令是：git checkout master &lt;重要&gt;合併分支：讓master吃到dev最新狀態我們目前的狀態是 master 目前的版本比較舊，而 dev 的版本比較新，所以接下來我們要做的事情，就是讓 master 可以吃到 c3、c4 的 commit。 因為目前 master 版本比較舊，你就必須先用 git checkout master 指令，讓 HEAD 移動到 master。 確保有切換後，就可以下此指令：git merge dev此時，master 位置就會在 c4 了。 快轉模式 vs 非快轉模式當你的 HEAD 位置是某個要被 merge branch(dev) 上的初始 commit，就會觸發快轉模式。 但如果在 master 再新增一個 commit 的話，就不會觸發快轉模式。","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/Git/"}]},{"title":"Git_分支","slug":"0227","date":"2020-01-21T16:00:00.000Z","updated":"2020-05-14T10:15:47.374Z","comments":true,"path":"2020/01/22/0227/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2020/01/22/0227/","excerpt":"","text":"分支建立(git branch)分支的好處，就是每一條線都各司其職，做完事後，再將兩條線的功能合併，並部署上線。 原狀態 新增分支接下來，我們想要開始新增新功能，但又不能污染到目前 master 的穩定版本狀態，於是我們新增一個 dev 分支，指令是：git branch dev 切換至分支當我們要切換分支時，指令是：git checkout dev 新增分支上commit再來我們就開始在 dev 上開發，並新增兩個commit。 切換回主狀態接下來我們切換回 master 看它的狀態。指令是：git checkout master &lt;重要&gt;合併分支：讓master吃到dev最新狀態我們目前的狀態是 master 目前的版本比較舊，而 dev 的版本比較新，所以接下來我們要做的事情，就是讓 master 可以吃到 c3、c4 的 commit。 因為目前 master 版本比較舊，你就必須先用 git checkout master 指令，讓 HEAD 移動到 master。 確保有切換後，就可以下此指令：git merge dev此時，master 位置就會在 c4 了。 快轉模式 vs 非快轉模式當你的 HEAD 位置是某個要被 merge branch(dev) 上的初始 commit，就會觸發快轉模式。 但如果在 master 再新增一個 commit 的話，就不會觸發快轉模式。","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/Git/"}]},{"title":"Vue_class動態切換Style(實作)","slug":"0115","date":"2020-01-14T16:00:00.000Z","updated":"2020-05-14T14:57:13.035Z","comments":true,"path":"2020/01/15/0115/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2020/01/15/0115/","excerpt":"","text":"實作目的點擊按鈕後的切換物件的型態，可使用判斷式來開關呈現的狀態 執行步驟在data裡新增一個變數以布林值為判斷單位 1234data: &#123; isTransform : false &#125;, 載入style變更box型態 123456789&lt;style&gt;.box &#123; transition: transform .5s;&#125;.box.rotate &#123; transform: rotate(45deg)&#125;&lt;/style&gt; 套用公式 :class=”{‘classname : 判斷式’}” 12345&lt;div id=\"app\"&gt; &lt;div class=\"box\" :class=\"&#123;'rotate':isTransform&#125;\"&gt;&lt;/div&gt; &lt;hr&gt; &lt;button class=\"btn btn-outline-primary\" @click =\"isTransform = !isTransform\" &gt;選轉物件&lt;/button&gt;&lt;/div&gt; isTransform置換的兩種方式 直接將A=!A寫入html，當@click點擊觸發後便會產生true跟false置換 1@click =\"isTransform = !isTransform\" @click後方寫入js函數內，並使用method將A=!A寫入運算內容也可以 1234methods: &#123; changeRotate: function() &#123; this.isRotate = !this.isRotate; &#125;,","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/Vue/"}]},{"title":"Git_基本建置指令","slug":"0121","date":"2020-01-11T16:00:00.000Z","updated":"2020-05-14T09:29:39.671Z","comments":true,"path":"2020/01/12/0121/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2020/01/12/0121/","excerpt":"","text":"Git 與 Github ？ Git 是一個分散式版本控制軟體，可藉由它產生一個儲存庫( git Repository)。 Github：支援 git 程式碼存取和遠端托管儲存庫的平台服務 關係像是本地端有一個 index.html，但可以放到 dropbox、Google Drive 進行雲端託管 設定基本資料輸入姓名：git config –global user.name “gon”輸入個人的 email：git config –global user.email “gonsakon@gmail.com“查詢 git 設定內容：git config –list Git指令架構圖 123456789初始化數據庫： git init開啟 .git 隱藏檔查詢當前狀態：git status將檔案加入到索引：git add .將索引檔案變成一個更新(commit)：git commit -m “修改內容”觀察 commit 歷史紀錄： git log下載遠端數據庫： git clone 數據庫網址更新遠端數據庫： git push origin master 終端機指令學習輸入「control + 空白」，關鍵字輸入「終端機」","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/Git/"}]},{"title":"Vue_修飾符","slug":"0108","date":"2020-01-07T16:00:00.000Z","updated":"2020-05-14T07:27:42.051Z","comments":true,"path":"2020/01/08/0108/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2020/01/08/0108/","excerpt":"","text":"事件修飾符常用：v-on:click只需在後方新增prevent語法(防止防止頁面上移) 1&lt;a href=\"#\" class=\"btn btn-info\" v-on:click.prevent=\"reversetext\"&gt; 按鍵修飾符 v-on == @原寫法：v-on:click=”函數”修飾寫法：@click=”函數” v-blid ==:原寫法：v-blid:href=”link”修飾寫法：:href=”link” Modifiers 修飾符.lazy原本雙向綁定的更新方式是以 input 事件監聽，亦即資料變動即更新，但使用.lazy會改用 change 事件監聽，event trigger 才更新。此時若要新增一個屬性用來計算總共有多少隻家禽，如下： number修飾符將字串轉為數字，在後方加入number即可將輸入的字串轉為數字 1&lt;input type =\"number\" class=\"form-control\" v-model.number=\"age\"&gt; trim緊貼文字當輸入文字夾雜著空格時，使用trim便可以刪去空格，文字便可以相連 1&lt;input type =\"text\" class=\"form-control\" v-model.trim=\"age\"&gt;&gt;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/JavaScript/"}]},{"title":"Bootstrap：滾動監聽Scrollspy(實作)","slug":"1228","date":"2019-12-27T16:00:00.000Z","updated":"2020-05-14T07:08:03.304Z","comments":true,"path":"2019/12/28/1228/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2019/12/28/1228/","excerpt":"","text":"滾動監聽（Scrollspy）插件，即自動更新導航插件，會根據滾動條的位置自動更新對應的導航目標。其基本的實現是隨著您的滾動，基於滾動條的位置嚮導航欄添加.active class。 使用方法向頂部導航添加滾動監聽行為： 通過data屬性：向您想要監聽的元素（通常是body）添加data-spy=“scroll”。然後添加帶有Bootstrap .nav組件的父元素的ID或class的屬性data-target。為了它能正常工作，您必須確保頁面主體中有匹配所要監聽鏈接的ID的元素存在。 123456789&lt;body data-spy =“ scroll” data-target =“main-nav”&gt;...&lt;div class =“ navbar-example”&gt; &lt;ul class =“ nav nav-tabs”&gt; ... &lt;/ ul&gt;&lt;/ div&gt;...&lt;/ body&gt; 通過JavaScript：您可以通過JavaScript調用滾動監聽，選取要監聽的元素，然後調用.scrollspy()函數： 12345678910111213141516//Init Scrollspy$('body').scrollspy(&#123; target:'#main-nav'&#125;);//Smooth Scrolling$('#main-nav a').on('click',function(event)&#123; if(this.hash !==\"\")&#123; event.preventDefault(); const hash = this.hash; $('html,body').animate(&#123; scrollTop: $(hash).offset().top &#125;, 700, function()&#123; window.location.hash = hash; &#125;) &#125;&#125;) 實作Nav監聽: 一頁式官網","categories":[],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/Bootstrap/"}]},{"title":"JavaScript_定義全域環境","slug":"1222","date":"2019-12-21T16:00:00.000Z","updated":"2020-05-14T06:44:35.970Z","comments":true,"path":"2019/12/22/1222/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2019/12/22/1222/","excerpt":"","text":"一旦執行JavaScript程式， 程式碼都是在執行環境（execution context）裡面建立和執行。(執行環境：一個wrapper，把正在執行的程式碼包在執行環境裡面。) 然而相較於執行環境，另外有一個基礎執行環境(base execution context)，又稱做全域執行環境。 全域(Global)‘Global’ means ‘not inside a function’簡而言之，當程式碼或變數不再函式中，就是全域的。 全域環境在全域執行環境中，JavaScript會自動創造兩個東西： Global Object：全域物件 this：一個特殊的變數 全域物件「全域物件」，可以在任何地方被取用。 this變數在沒有寫任何程式碼的情況之下，啟用window瀏覽器執行，這時候全域執行環境中會自動產生一個全域物件-window物件，以及this這個特殊變數。 同一個瀏覽器，開啟另一個分頁，就會創建另外一個全域執行環境，也會獨立產生一個全域物件及this變數。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/JavaScript/"}]},{"title":"Bootstrap_影片彈出視窗(實作)","slug":"1219","date":"2019-12-18T16:00:00.000Z","updated":"2020-05-14T06:56:50.870Z","comments":true,"path":"2019/12/19/1219/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2019/12/19/1219/","excerpt":"","text":"目的：點擊影片後顯示彈出視窗，並自動播放影片內容 設置HTML樣板 12345678910111213141516 &lt;!-- VIDEO PLAY --&gt;&lt;section id=\"video-play\"&gt; &lt;div class=\"dark-overlay\"&gt; &lt;div class=\"container p-5\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt; &lt;a href=\"#\" class=\"video\" data-video=\"https://www.youtube.com/embed/SjJ08V166uU\" data-toggle=\"modal\" data-target=\"#videoModal\"&gt; &lt;i class=\"fas fa-play fa-3x\"&gt;&lt;/i&gt;&lt;!--data-toggle 通常會伴隨一個icon，告知系統在點擊後會觸發另一個行動 --&gt; &lt;/a&gt; &lt;h1&gt;Watch Our Publicity Film&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 點擊後開啟Modal互動視窗 1234567891011121314&lt;!-- VIDEO MODAL --&gt;&lt;div class=\"modal fade\" id=\"videoModal\"&gt; &lt;!--點擊後淡化原視窗背景顏色 --&gt; &lt;div class=\"modal-dialog\"&gt;&lt;!-- 影片左右置中進行--&gt; &lt;div class=\"modal-content\"&gt; &lt;div class=\"modal-body\"&gt; &lt;button class=\"close\" data-dismiss=\"modal\"&gt;&lt;!--關閉鈕 --&gt; &lt;span&gt;&amp;times;&lt;/span&gt; &lt;/button&gt; &lt;iframe src=\"\" frameborder=\"0\" height=\"350\" width=\"100%\" allowfullscreen&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 套用JQ影片播放語法 1234567891011121314// Video Play$(function () &#123; // Auto play modal video $(\".video\").click(function () &#123; var theModal = $(this).data(\"target\"), videoSRC = $(this).attr(\"data-video\"), videoSRCauto = videoSRC + \"?modestbranding=1&amp;rel=0&amp;controls=0&amp;showinfo=0&amp;html5=1&amp;autoplay=1\"; $(theModal + ' iframe').attr('src', videoSRCauto); $(theModal + ' button.close').click(function () &#123; $(theModal + ' iframe').attr('src', videoSRC); &#125;); &#125;);&#125;); 實作成品彈出式影片: 運動頻道","categories":[],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/Bootstrap/"}]},{"title":"JavaScript_動態型別","slug":"1218","date":"2019-12-17T16:00:00.000Z","updated":"2020-05-14T06:37:24.555Z","comments":true,"path":"2019/12/18/1218/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2019/12/18/1218/","excerpt":"","text":"動態型別在JavaScript中，不需要宣告變數的型別，因為JavaScript是使用「動態型別」在處理變數。僅需要宣告變數(type)，不需要告訴JavaScript變數的型別(type)，它會在執行程式時，自動判別變數的型別，而且一個變數在不同時候可能擁有不同型別。 JavaScript的六種純值(primitive)純值是一種資料型別，代表基本型別，只是一個值，而非物件。 undefinedJavaScript給所有變數的初始值，變數會一直處於undefined，直到程式碼執行到設定變數的值 null表示不存在，可以在程式宣告時，給與該變數的值為null，用以表示該變數沒有值。 boolean表示對或錯，用true或false表示值 Number(數值)在JavaScript中的數值皆為浮點數，不像其他程式語言還會細分整數或其他浮點數等，所以在JavaScript中也可以直接把他假裝為整數。 String(字串)由一連串字符所組成，可以單引號或雙引號表示 Symbal(符號)這是新的型別，被用在ES6中，尚未被全部的瀏覽器支援 強制型轉(Coercion)JavaScript引擎自動將1轉換為字串’1’，才繼續做相加運算，自動避免出錯 12var a = 8 + '7';console.log(a);//87","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/JavaScript/"}]},{"title":"JavaScript_物件傳參考特性","slug":"1215","date":"2019-12-14T16:00:00.000Z","updated":"2020-05-14T06:22:17.891Z","comments":true,"path":"2019/12/15/1215/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2019/12/15/1215/","excerpt":"","text":"定義 傳值(Call by value)：在 JavaScript 中的純值 是傳值。(傳過去以後就沒有任何關聯性) 傳參考/傳參照(Call by reference)：傳遞給函式的是它實際參數的隱式參照，而不是實際的拷貝。 傳共用物件(Call by sharing)： a 與 b 是共用同一個物件內容，若 b 修改了物件內容，則 a 也會被修改成同樣內容(物件是共用的，沒有拷貝)。 12345678910111213141516// 傳值var person = '小明'; // 純值var person2 = person;person2 = '杰倫';console.log(perosn, person2)// 小明,杰倫//傳參考var person = &#123; name: '小明'&#125;;var person2 = person;perosn2.name = '杰倫'; // 改變物件內容console.log(perosn, person2);console.log(perosn === person2);// 杰倫,杰倫// true More info: 傳值、傳參考 應對方式：Object.assign 操作測試12345 openModal(item)&#123; //this.tempProduct= item; //因為物件傳參考的特性，直接用item會與tmepProduct相同 this.tempProduct= Object.assign(&#123;&#125;,item); //可採用es6語法，將item傳自獨立的空物件裡，才不會互相渲染&#125;, 無法直接指定匯入變數中，因傳參考的特性會互相渲染，需將item傳入空物件裡才能順利使用。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/JavaScript/"}]},{"title":"CSS_統整display各種屬性","slug":"1212","date":"2019-12-11T16:00:00.000Z","updated":"2020-05-14T06:11:52.841Z","comments":true,"path":"2019/12/12/1212/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2019/12/12/1212/","excerpt":"","text":"display: block不論前後元素為何，display:block 元素會直接「換行」開始。&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;、&lt;h2&gt;、&lt;iframe&gt;、&lt;img&gt;這幾個 HTML 元素預設的 display 屬性是 block可以自定義寬高或縮排(margin 、 padding 、 width 、 height 、 background-image 皆「有效」) display: inlinedisplay : inline 的元素連在一起會在同一行，「不會換行」。要讓 display : inline 元素水平置中的方式是在此元素的父元素加上 text-align : center。&lt;a&gt;、&lt;span&gt;、&lt;b&gt;、&lt;i&gt;、&lt;iframe&gt;、&lt;img&gt;這幾個 HTML 元素預設的 display 屬性是 inline可以針對左右做縮排(margin-left 、 margin-right 、 padding-left 、 padding-right「有效」)上下縮排會失效，且寬高為內容本身寬高，無法自定義寬高。 (margin-top 、 margin-bottom 、 padding-top 、 padding-bottom 、 width 、 height 、 background-image 皆「無效」) display: inline-block內部元素水平排列，而且不需要額外設定clear，也不會讓接著的元素疊上來。可以理解為：外面是inline，裡面是block。所以元素「不會換行」，但是又可以設定元素的padding-top 、 padding-bottom 、 width 、 height 、 background-image 。 display: nonedisplay設為none這個東西就不見了，不佔空間。補充：visibility:hidden是隱形看不見，不過還是有佔空間","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/CSS/"}]},{"title":"Bootstrap_Lightbox影像燈箱","slug":"1211","date":"2019-12-10T16:00:00.000Z","updated":"2020-05-14T06:05:19.586Z","comments":true,"path":"2019/12/11/1211/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2019/12/11/1211/","excerpt":"","text":"主要功能是點選照片，該張照片會以燈箱方式全版展開，提升觀看體驗，請參考Lightbox for Bootstrap進行安裝 結構分為兩層 外層定義燈箱展示的照片，以及展示後的大小 內層定義原始照片 在外層使用bootstrap自定義的data-toggle設定啟用lightbox功能;data-lightbox將多張照片群組起來，在左右切換照片時可以辨識為同一群組的照片 新增程式碼至html裡使data-toggle串連lightbox 123&lt;a href=\"https://unsplash.it/1200/768.jpg?image=250\" data-toggle=\"lightbox\" data-title=\"A random title\" data-footer=\"A custom footer text\"&gt; &lt;img src=\"https://unsplash.it/600.jpg?image=250\" class=\"img-fluid\"&gt;&lt;/a&gt; 最後添加jquery程式碼，避免預設效果，而採用引入的lightbox效果展示 1234$(document).on('click', '[data-toggle=\"lightbox\"]', function(event) &#123; event.preventDefault(); $(this).ekkoLightbox();&#125;); 實作燈箱畫冊: 運動頻道","categories":[],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/Bootstrap/"}]},{"title":"CSS_圖片取代文字(SEO優化)","slug":"1204","date":"2019-12-03T16:00:00.000Z","updated":"2020-05-14T05:44:40.465Z","comments":true,"path":"2019/12/04/1204/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2019/12/04/1204/","excerpt":"","text":"SEO搜尋優化文字在SEO中的影響力仍然大於圖片，但我們也不可忽視圖片搜尋的趨勢。要兼顧排版及SEO，建議以圖文並茂、相輔相成的方式進行，若是因為版面限制，則可以運用其他可以放文字的區塊、頁面，將圖片中的內容轉換成文字，讓搜尋引擎爬蟲知道你的網站中也有這些內容！ 瀏覽器爬蟲網頁的過程會以搜尋文字為主，採用此形式協助網站做SEO優化 目的：標題內新增圖片，讓logo背景蓋住文字內容 123456789.logo h2&#123; background-image: url(/photo/logoword.jpg); width: 200px; height: 300px; display:block; overflow: hidden; text-indent:101%; white-space:nowrap; &#125; text-indent: 101% 這是表示 段落首字縮排，將文字推出logo背景 overflow: hidden;超出 div 父元素時，自動隱藏該元素 white-space: nowrap：規定段落中的文字不得進行換行，常用於避免字數過多時自動換行導致閱讀效果變差","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/CSS/"}]},{"title":"JavaScript_基礎語法：switch判斷式","slug":"1204-2","date":"2019-12-03T16:00:00.000Z","updated":"2020-05-14T05:52:03.531Z","comments":true,"path":"2019/12/04/1204-2/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2019/12/04/1204-2/","excerpt":"","text":"switch與if的差異if else 會把每個條件跟程式碼都檢視過一次，而 switch 只會去檢視 case 內的條件是否吻合，吻合才去執行程式碼區塊，相對來說，if else 會比較消耗效能，因if語法瀏覽器會都進行處理，而switch需對應後才處理，並且跑到指定需求後便停止。除了比if語法有較快的效率，使程式碼更好閱讀，同時效能較佳， 使用時機如有確定特定狀態便推薦使用switch，ex：只有紅燈、黃燈、綠燈三種 1234567891011121314151617var light = yellow;switch(light)&#123; // 如果是紅色就執行這區塊的程式碼 case 'red': console.log('現在是'+light); break; // 如果是黃色就執行這區塊的程式碼 case 'yellow': console.log('現在是'+light); break; // 如果上述都沒有符合的條件，就執行這區塊的程式碼 default: console.log('現在是綠燈'); break;&#125;&#125; switch嚴謹模式12345678910111213var n = '5';switch(n)&#123; case 5: console.log('success'); break; default: console.log('fail'); break;&#125;// console 輸出 fail&#125; 看起來同樣的判斷卻在 switch 和 if else 上有著不一樣的結果，這是因為 switch 在判斷上採取嚴謹模式，亦即 ===(即型別也要相同)，而在 if else 的判斷上並沒有採取這麼嚴謹的模式，需更改case’5’才能正確運行 12345678910111213switch(n)&#123; case '5': console.log('success'); break; default: console.log('fail'); break;&#125;// console 輸出 success&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/JavaScript/"}]},{"title":"Slick_迅速搭建的輪播套件","slug":"1202","date":"2019-12-01T16:00:00.000Z","updated":"2020-05-14T06:07:06.081Z","comments":true,"path":"2019/12/02/1202/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2019/12/02/1202/","excerpt":"","text":"介紹Slick官網提供多種輪播樣式，可進行滑動、設定輪播等功能，我們只需要選定輪播形式後，引用js、css套件，即可使用它所支援的slider樣式。 操作步驟搜尋並引入slick cdn，加入css及js相對應程式碼 將slick.css複製到中 12&lt;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.9.0/slick.css\" /&gt;&lt;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.9.0/slick-theme.css\" /&gt; slick.js複製到段底部 12&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.9.0/slick.js\"&gt;&lt;/script&gt; 在html建立輪播的內容結構，並在外層使用一個class作標記 1234567&lt;div class=\"slider\"&gt; &lt;div&gt;slide 1&lt;/div&gt; &lt;div&gt;slide 2&lt;/div&gt; &lt;div&gt;slide 3&lt;/div&gt;&lt;/div&gt; 在slick官網上選擇sliders樣式，複製對應語法到body、script中 經由optional控制元素來調整輪播、滑動等功能設定 12345678910111213arrows: (boolean值)是否顯示左右箭頭功能dots:(boolean值)是否顯示下方小圓點功能autoplay：(boolean值)是否自動播放autoplaySpeed:(毫秒值)自動播放的速度slidesToShow:(數量值)一次主要顯現幾個slidesslidesToScroll:(數量值)每次滑動幾張slidesfade:(boolean值)是否採用淡出/淡入效果infinite：(boolean值)滑到最後一張，是否繼續從回到一開始同向循環(4&gt;1&gt;2&gt;3&gt;…)，或是逆轉向循環(4&gt;3&gt;2&gt;…)centerMode:(boolean值)是否同時顯現前後兩張slide的部分內容centerPadding:(px值)搭配centerMode:true使用，表示前後兩張slide要顯現多少範圍responsive:(陣列)針對不同尺寸做額外設定breakpoint:(螢幕尺寸)settings:(&#123;物件&#125;)包含各種設定 實作Slick幻燈片: 運動頻道","categories":[],"tags":[{"name":"Slick","slug":"Slick","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/Slick/"}]},{"title":"JavaScript_基礎語法：呼叫函式實作","slug":"1127","date":"2019-11-26T16:00:00.000Z","updated":"2020-05-14T07:12:24.637Z","comments":true,"path":"2019/11/27/1127/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2019/11/27/1127/","excerpt":"","text":"創建一個物件： 1234567 var farm = &#123; duck: 5 chicken: 10, dogs: ['柴犬','柯基'], cornField: [5,6,7]&#125; 此時若要新增一個屬性用來計算總共有多少隻家禽，如下： 1234567891011var farm = &#123; duck: 5, chicken: 10, dogs: ['柴犬','柯基'], cornField: [5,6,7], poultry: function()&#123; var total = this.duck + this.chicken; console.log(total); &#125;,&#125; 我們新增了一個 poultry 屬性，並給予一個計算小鴨跟小雞數量的函式(這裡函式可以不用命名)，當然除了上述的第一個方法，我們也可以中途加入 poultry 這個屬性，如下 12345farm.poultry = function ()&#123; var total = this.duck + this.chicken; console.log(total);&#125; 而當我們在呼叫屬性且有函式時，會比較不一樣 12farm.poultry(); 有屬性若為函式，需要跟前面講到函式時一樣，跟函式的呼叫一樣需要加括號","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/JavaScript/"}]},{"title":"JavaScript_基礎語法：===等號間的嚴謹模式","slug":"1127_2","date":"2019-11-26T16:00:00.000Z","updated":"2020-05-14T07:12:19.935Z","comments":true,"path":"2019/11/27/1127_2/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2019/11/27/1127_2/","excerpt":"","text":"有一個較為嚴謹的比較模式，當等號使用==時，左右兩邊並不會比較資料型別，而會自動去轉型做比較，專業回答：兩個等於（==）會對被判別的變數做轉換型別的動作（coercion又稱為implicit type conversion） 例如：1 == ‘1’，數字1等於字串1，這時候會回傳 true，JavaScript 會自動把字串1先轉型成數字1，再去做比較 如果在===的情況下，1 === ‘1’ ，數字1並不會等於字串1，會回傳 false 因為數字跟字串本身就是不一樣的資料型別，所以在比較的時候會先從資料型別去做比較，如果兩邊的資料型別不一樣，則就先回傳 false ，所以這是較嚴謹的比較模式。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/JavaScript/"}]},{"title":"JavaScript_語法解析、執行/詞彙環境","slug":"1123_1","date":"2019-11-22T16:00:00.000Z","updated":"2020-05-14T04:14:12.660Z","comments":true,"path":"2019/11/23/1123_1/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2019/11/23/1123_1/","excerpt":"","text":"語法解析器(syntax parser)包含直譯器、編譯器，會一個字一個字讀取並辨識程式碼是否有效，再將之轉換成為電腦可以解讀的指令 詞彙環境(lexical environment)程式碼在程式中實際的所在位置，對於某些程式語言非常重要，例：JavaScript。 因為當systax parser在解讀並轉換程式碼時， 會考量該變數、函式的lexical environment，而影響到它實際在記憶體中的位置或是跟其他變數、函式作用的關係。 123function hello()&#123; var a = 'Hello';&#125; 變數a的lexical environment就是hello()這個函式。 執行環境(execution context)一個程式碼中有多個lexical environment，因此execution context負責協助管理正在執行的程式，如同一個wrapper，包含我們撰寫的程式碼，以及syntax parser執行轉換的程式碼。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/JavaScript/"}]},{"title":"JavaScript_基礎語法：渲染id/屬性","slug":"1123_2","date":"2019-11-22T16:00:00.000Z","updated":"2020-05-14T04:31:54.418Z","comments":true,"path":"2019/11/23/1123_2/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2019/11/23/1123_2/","excerpt":"","text":"代入id渲染方式在 JavaScript 裡，當想要選取一個 id 渲染到網頁上時，可以使用下面的語法： 1document.getElementById(''); 假使今天想要選取一個 id 且為hello，則可以這樣寫： 12document.getElementById('hello'); 接下來介紹一個新增文字的方式，再選取完一個 id 且為hello時，想渲染一些文字時，可以如下：document.getElementById(‘hello’).textContent = ‘這是一段文字’; 實作12345&lt;p id=\"test\"&gt;文字1&lt;/p&gt;&lt;script&gt; document.getElementById('test').textContent=\"修改後標題\";&lt;/script&gt; 12&lt;p id=\"test\"&gt;修改後標題&lt;/p&gt;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/JavaScript/"}]},{"title":"JavaScript_基礎語法：呼叫函式實作","slug":"1123_3","date":"2019-11-22T16:00:00.000Z","updated":"2020-05-14T04:35:59.998Z","comments":true,"path":"2019/11/23/1123_3/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2019/11/23/1123_3/","excerpt":"","text":"創建一個物件： 1234567 var farm = &#123; duck: 5 chicken: 10, dogs: ['柴犬','柯基'], cornField: [5,6,7]&#125; 此時若要新增一個屬性用來計算總共有多少隻家禽，如下： 1234567891011var farm = &#123; duck: 5, chicken: 10, dogs: ['柴犬','柯基'], cornField: [5,6,7], poultry: function()&#123; var total = this.duck + this.chicken; console.log(total); &#125;,&#125; 我們新增了一個 poultry 屬性，並給予一個計算小鴨跟小雞數量的函式(這裡函式可以不用命名)，當然除了上述的第一個方法，我們也可以中途加入 poultry 這個屬性，如下 12345farm.poultry = function ()&#123; var total = this.duck + this.chicken; console.log(total);&#125; 而當我們在呼叫屬性且有函式時，會比較不一樣 12farm.poultry(); 有屬性若為函式，需要跟前面講到函式時一樣，跟函式的呼叫一樣需要加括號","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/JavaScript/"}]},{"title":"JavaScript_宣告事件的三種方式","slug":"1120","date":"2019-11-19T16:00:00.000Z","updated":"2020-05-14T04:07:43.802Z","comments":true,"path":"2019/11/20/1120/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2019/11/20/1120/","excerpt":"","text":"一般在撰寫事件有三種方式，第一種也是較為早期的一種，也是不推薦使用的方式，因為較容易受到外來的攻擊，關鍵是在 onclick=“hello();” 在這裡面可以撰寫 JS，所以也較容易受到外來的方式改寫程式碼，也是較為危險的方式 第一種1&lt;input type=\"button\" class=\"btn\" value=\"點擊\" onclick=\"hello();\"&gt; 第二種直接把事件內容全寫在 JS 檔內，而不是 HTML 內 12345var el = document.querySelector('.btn');el.onclick = function()&#123; alert('Hello');&#125; 第三種採用addEventListener() 方法，俗稱事件監聽，來做事件的綁定 12345var el = document.querySelector('.btn');el.addEventListener('click',function()&#123; alert('Hello');&#125;) 比較彼此差異撇除掉第一種較危險的方式之外，來談談第二種跟第三種的差異性這兩個方法差異性在哪裡？假設我們今天同一個元素要綁定多個事件時：當採用第一種方法 12345678910&lt;script&gt; var el = document.querySelector('.btn'); el.onclick = function()&#123; alert('Hello1'); &#125; el.onclick = function()&#123; alert('Hello2'); &#125;&lt;/script&gt; 這時候只會彈跳 Hello2 出來，第一個 click 事件被蓋掉了，而使用另外一種方法時 123456789101112&lt;script&gt; var el = document.querySelector('.btn'); el.addEventListener('click',function()&#123; alert('Hello1'); &#125; &#125;) el.addEventListener('click',function()&#123; alert('Hello2'); &#125; &#125;) &lt;/script&gt; 這時候會發現，會依序彈跳 Hello1 Hello2，事件會依序出來，並不會被蓋掉上述就是其差異性，為了避免這種狀況，建議之後可以改用 .addEventListener()的方式","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/JavaScript/"}]},{"title":"JavaScript_解析BOM與DOM","slug":"1120_2","date":"2019-11-19T16:00:00.000Z","updated":"2020-05-14T04:08:08.904Z","comments":true,"path":"2019/11/20/1120_2/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2019/11/20/1120_2/","excerpt":"","text":"什麼是BOM？瀏覽器物件模型（Browser Object Model,BOM）是瀏覽器提供的附加對象，用於處理 document 以外的所有内容，主要處理瀏覽器窗口和框架，不过通常瀏覽器特定的 JavaScript 也會被看作 BOM 的一部分。區別：BOM 描述了與瀏覽器進行交互的方法和接口，DOM 描述了處理網頁内容的方法和接口。 window 物件包含属性：document、navigator、frames、history、location、screen document 根節點包含子節點：forms、location、anchors、images、links 什麼是DOM(Document Object Model)？檔案物件模型（Document Object Model, DOM）是瀏覽器的執行規範，提供了結構化的標準方法，將網頁的程式碼及其他程式語言結合起來。開發人員即可以通過文件中物件的屬性、方法和事件來掌控、操縱和建立動態的網頁元素。 每個 DOM 的基礎建置在一個(D)文件上（也就是以 document 作為根基），而由 document 中的每個(O)物件作為出一個個節點，最後由這一個個節點，組成為一個 DOM Tree。 D：（文件）瀏覽器當前載入的 document O：（物件）將 document 中的所有元素視為物件，可以調用其屬性、方法 M：（模型）所有的物件在該結構中都是節點，這些眾多節點組成一個樹狀結構 DOM 節點有: 元素節點：上圖中html、body、p標籤皆是元素節點。 文本節點:向用户展示的内容，如li…/li中的 JavaScript、DOM、CSS 等文本。 屬性節點:標籤中的屬性，如a標籤中的連結屬性href=”http://www.yahoo.com&quot;。 DOM 操作用 DOM API 可以輕鬆地删除、添加和替換節點。| DOM 操作 |说明 || ————- |:————-:||creatElement(element) |創建一个新的元素節點||creatTextNode() |創建一个包含給定文本的新文本節點||appendChild() |指定節點的最後一個節點列表後添加一个新的子節點||insertBefore() |將一個給定節點节点插入到一个給定元素節點的給定子節點的前面||removeChild() |从一个给定元素中删除子节点||replaceChild() |把一个给定父元素里的一个子节点替换为另外一个节点|","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/JavaScript/"}]},{"title":"Bootstrap_navbar導覽頁面","slug":"1115","date":"2019-11-14T16:00:00.000Z","updated":"2020-05-14T03:45:58.025Z","comments":true,"path":"2019/11/15/1115/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2019/11/15/1115/","excerpt":"","text":"navbar導覽使用方式 nav外層使用包住時，Navbar導覽列放置在頁面中央或內容的中間，若沒有設定container，導覽列預設的內容寬度是浮動，並自動佔滿水平寬度 透過navbar-expand定義在何種尺寸，menu項目的呈現會改為「漢堡折疊」樣式效果 使用bootstrap自定義的data-toggle及data-target，決定按鈕點下之後，menu的div要以collapse方式展開 navbar-expand-sm大小則是決定當螢幕尺寸小於sm時，會改為以「三」顯示menu項目 123456789101112131415161718192021222324252627&lt;nav id=\"main-nav\" class=\"navbar navbar-expand-sm navbar-dark fixed-top\" &gt;&lt;nav class=\"nav navbar-default\"&gt; &lt;div class=\"container-fluid\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\"#Navbarshow\"&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=\"navbar-brand\" href=\"#\"&gt;Brand&lt;/a&gt; &lt;/div&gt; &lt;div class=\"collapse navbar-collapse\" id=\"Navbarshow\"&gt; //底下放要縮放的內容 &lt;ul class=\"nav navbar-nav\"&gt; &lt;li&gt;&lt;a data-toggle=\"tab\" href=\"#home\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a data-toggle=\"tab\" href=\"#menu1\"&gt;Page 1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a data-toggle=\"tab\" href=\"#menu2\"&gt;Page 2&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"nav navbar-nav navbar-right\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;span class=\"glyphicon glyphicon-log-in\"&gt;&lt;/span&gt; Log in&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Log out&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;span class=\"glyphicon glyphicon-user\"&gt;&lt;/span&gt; Admin&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt; 建立漢堡按鍵步驟 class=”navbar-toggle”：這個是關鍵字，有它才能讓我們順利看到漢堡按鍵，並出現在視窗右方。 data-toggle=”collapse”：這是用來製作動畫效果的，沒有的話，我們點「三」的時候不會有任何反應。 data-target=”#myNavbar”這裡面的myNavbar是一個CSS的id，可以任意命名，一定要跟下面縮放的id對應才可執行。 這段這是用來產生「一」，當有三個「一」時，合在一起就會變「三」的按鍵了。 class=”collapse navbar-collapse”：這兩字詞幫助我們在正常視窗的情況下，可以看到原本的導覽列。 id=”Navbarshow”與button裡的data-target做對應，能讓我們看到縮放裡的內容 如果希望navbar不會受頁面捲動下移而消失，則在class加上fixed-top，變會置頂在最上方","categories":[],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/Bootstrap/"}]},{"title":"Bootstrap_Collapse & Accordion折疊語法","slug":"1114","date":"2019-11-13T16:00:00.000Z","updated":"2020-05-14T03:41:11.974Z","comments":true,"path":"2019/11/14/1114/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2019/11/14/1114/","excerpt":"","text":"什麼是Collapse折疊？使特定的頁面區塊隱藏起來，當點擊某些按鈕或者動作時，資料才會顯現出來。 12345&lt;button data-toggle=\"collapse\" data-target=\"#demo\"&gt;Collapsible&lt;/button&gt;&lt;div id=\"demo\" class=\"collapse\"&gt;Lorem ipsum dolor text....&lt;/div&gt; 按鈕上一定要有 data-toggle=“collapse” 這個宣告詞，然後需要顯示的資訊在 data-target=”#demo” 的連結上。 再利用 div 或者是其他區塊類的元素，增加 id=“demo”，重要的是 demo 跟 button 的 data-target 命名必須相同才可運作。 預設的折疊效果是隱藏的，點擊才會出現，若要設定為展開開狀態，在collapse後方添加show便可顯現。 Accordion隱藏折疊資料透過 Accordion 的方法來處理時，看起來所有的連結會比較整齊， FAQ 問答頁面多使用這種模式。 123456789101112131415161718&lt;div id=\"accordion\" &gt; &lt;div class=\"card\"&gt; &lt;div class=\"card-header\"&gt; &lt;h5 class=\"mb-0\"&gt; &lt;div href=\"#collapse1\" data-toggle=\"collapse\" data-parent=\"#accordion\"&gt; &lt;i class=\"fas fa-chevron-circle-down\"&gt;&lt;/i&gt; Good Deal&lt;/div&gt; &lt;/h5&gt; &lt;/div&gt; &lt;div id=\"collapse1\" class=\"collapse show\"&gt; &lt;div class=\"card-body\"&gt; Lorem ipsum dolor, sit amet consectetur adipisicing elit... &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 實作成果","categories":[],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/Bootstrap/"}]},{"title":"Bootstrap_宣告指令（移動區塊、改變色系）","slug":"1113","date":"2019-11-12T16:00:00.000Z","updated":"2020-05-14T03:31:16.891Z","comments":true,"path":"2019/11/13/1113/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2019/11/13/1113/","excerpt":"","text":"色系調色盤-bg/text1&lt;p class=\"text-primary\"&gt;調整文字色系&lt;/p&gt; 移動位置區塊-p/m 移動y軸代表調整上下位置，x軸則是左右位置 pl= padding left| py= padding top &amp; bottom ml= margin left 響應式圖片 img-fluid自動縮放圖片寬度 rounded 可以讓圖片顯示圓角傚果 rounded-circle 可以設置橢圓形圖片 1&lt;img src=\"...\" class=\"img-fluid rounded\" alt=\"Responsive image\"&gt; 背景圖background-attachment是背景固定模式的屬性，而不同的固定模式就有不一樣的視覺效果 scroll模式也是預設值，背景圖會隨著外圍頁面滾動而移動。 fixed模式，不管外面、裡面怎麼滾，他都是不會動的。 local模式，主要的特色就是，自己的區塊內如果滾動時，背景圖也會跟著移動。 icon圖型i標籤將想使用的icon圖寫入欲出現位置 1&lt;i class=\"fas fa-band-aid\"&gt;&lt;/i&gt; More info: font-awesome","categories":[],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/Bootstrap/"}]},{"title":"Bootstrap_GridSystem 配置版面","slug":"1111","date":"2019-11-10T16:00:00.000Z","updated":"2020-05-13T17:09:40.684Z","comments":true,"path":"2019/11/11/1111/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2019/11/11/1111/","excerpt":"","text":"定義網格規則 Bootstrap使用flexbox建立網格系統，符合響應式設計，並且能夠更方便的實現等高及對齊置中效果。 定義列與行的語法，先決定外層row列數，再設定內層的寬度col，寬度bootstrap定義分成12等分， &lt;div class=&quot;col-[裝置尺寸]-[寬度大小]&quot;&gt; 定義螢幕尺寸(xs, sm, md, lg) 範例：&lt;div class=”col-md-6&gt; 在md的大小時會佔據6/12一半的寬度(深綠色)，程式碼如下: 1234567&lt;div class=\"row\"&gt; &lt;div class=\"col-md-12 text-center\"&gt;12/12&lt;/div&gt;&lt;/div&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-md-6 text-center\"&gt;6/12&lt;/div&gt; &lt;div class=\"col-md-6 text-center\"&gt;6/12&lt;/div&gt;&lt;/div&gt; 垂直對齊容器位置可以在.row的 class 加上：左-&gt;align-items-start右-&gt;align-items-end中-&gt;align-items-center 水平調整容器位置 補充資料 在預設的情況下，每一個欄（column）之間都會有間隙（gutter），透過在 .row 上加上 .no-gutters 即可去除 我們可以在同一個 column 上給多的 class 來讓頁面在不同螢幕尺寸時有不同的排版：&lt;div class=&quot;col-sm-4 col-md-8&quot;&gt;&lt;/div&gt;當螢幕尺寸為md以上時會以8/12顯示，sm則以4/12顯示","categories":[],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/Bootstrap/"}]},{"title":"Bootstrap_Carousel輪播幻燈片","slug":"1111_2","date":"2019-11-10T16:00:00.000Z","updated":"2020-05-14T06:00:27.038Z","comments":true,"path":"2019/11/11/1111_2/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2019/11/11/1111_2/","excerpt":"","text":"Carousel中文為幻燈片的意思，在元件裡面可以添加控制元素來控制幻燈片的播放。 組成結構分為三個元素組成 Carousel item Carousel controls Carousel indicators Carousel item項目12345678910111213&lt;div id=\"myCarousel\" class=\"carousel slide\" data-ride=\"carousel\"&gt; &lt;div class=\"carousel-inner\"&gt; &lt;div class=\"carousel-item active\"&gt; &lt;img class=\"d-block w-100\" src=\"img/bg1.jpg\" alt=\"slide01\"&gt; &lt;/div&gt; &lt;div class=\"carousel-item\"&gt; &lt;img class=\"d-block w-100\" src=\"img/bg2.jpg\" alt=\"slide01\"&gt; &lt;/div&gt; &lt;div class=\"carousel-item\"&gt; &lt;img class=\"d-block w-100\" src=\"img/bg3.jpg\" alt=\"slide01\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 添加一個carousel容器，他可以包裝整個幻燈片組建所需的元件 內容放在一個carousel-inner 容器裡並在項目中carousel-item放置圖片與資訊內容 d-block代表display:block為佔據一行，w-100表示寬度100 data-ride 讓幻燈片可以自動切換 預設頻率是每五秒更換一次，若需要有滑動效果可以在最外面加個 slide。 Controls控制項123456&lt;a href=\"#myCarousel\" data-slide=\"prev\" class=\"carousel-control-prev\"&gt; &lt;span class=\"carousel-control-prev-icon\"&gt; &lt;/span&gt;&lt;/a&gt;&lt;a href=\"#myCarousel\" data-slide=\"next\" class=\"carousel-control-next\"&gt; &lt;span class=\"carousel-control-next-icon\"&gt;&lt;/span&gt;&lt;/a&gt; 在data-slide分別設置prv及next以完成設定左右切換圖片的功能 indicators指示器12345&lt;ol class=\"carousel-indicators\"&gt; &lt;li data-target=\"#myCarousel\" data-slide-to=\"0\" class=\"active\"&gt;&lt;/li&gt; &lt;li data-target=\"#myCarousel\" data-slide-to=\"1\"&gt;&lt;/li&gt; &lt;li data-target=\"#myCarousel\" data-slide-to=\"2\"&gt;&lt;/li&gt;&lt;/ol&gt; 使用ol及li列表結構並套用carousel-indicators 每個li標籤對應一個slide，並將active加入到齊幻燈片內，否則輪播將看不見。 改變slide停留時間每張幻燈片預設的停留時間為5秒，如果想要改變停留的時間，可加上interval這個選項，調整滯留的秒數。 1234$('.carousel').carousel(&#123; interval: 6000, pause: 'hover' &#125;); 取消自動輪播將interval設為false即可取消自動輪播 123$('.carousel').carousel(&#123; interval: false&#125;) 鼠標滑入持續輪播Carousel預設是當鼠標滑入時，輪播就會暫停。若想要讓滑鼠滑入時繼續輪播，就可使用以下設定。 1234$('.carousel').carousel(&#123; pause: false&#125;) 停止循環播放bootstrap預設data-wrap：ture（循環播放），若投影片只想播放一個循環，更改為false即可停止無限循環。 12&lt;div id=\"myCarousel\" class=\"carousel slide\" data-wrap=\"false\" data-ride=\"carousel\"&gt; 實作成果首頁輪播: 運動頻道","categories":[],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/Bootstrap/"}]},{"title":"HTML_解析絕對/相對路徑","slug":"1110","date":"2019-11-09T16:00:00.000Z","updated":"2020-05-13T11:21:57.513Z","comments":true,"path":"2019/11/10/1110/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2019/11/10/1110/","excerpt":"","text":"定義「相對路徑」和「絕對路徑」 相對路徑是相對於現在目錄的路徑表示，也就是你現在這個檔案在哪裡，這個目錄的路徑起始點就在哪裡，所以每個檔案的相對路徑起始點都可能會不同 絕對路徑是一個絕對位置，他不會隨著檔案位置的變換而改變他的路徑。 舉例的路徑符號 「.」是代表目前所在目錄 「..」是代表上層目錄，若目前已經是根目錄則依然為目前所在目錄 「/」在各個目錄名稱之間的分隔符號，若放置在路徑之前則代表根目錄 相對路徑顯示圖片 絕對路徑顯示圖片","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/HTML/"}]},{"title":"CSS_轉場特效(transitions)","slug":"1102","date":"2019-11-01T16:00:00.000Z","updated":"2020-05-13T11:03:38.691Z","comments":true,"path":"2019/11/02/1102/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2019/11/02/1102/","excerpt":"","text":"使用時機想在滑鼠移上去的時候做一點效果，希望能讓整個頁面看起來更精緻，為了使畫面在轉場時變得生動，此時就很適合用到有漸變的動畫的transition。例：hover設定浮出來的效果（box shadow）並且變亮。注意：transition需寫在外層裡(尚未觸發前)，而非在hover效果層內 123456789101112131415&lt;section id=\"video-play\"&gt; &lt;div class=\"dark-overlay\"&gt; &lt;!-- 背景暗色 --&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt; &lt;div class=\"container p-5\"&gt;&lt;!-- padding --&gt; &lt;a href=\"#\" class=\"video\" data-video=\"https://www.youtube.com/embed/SjJ08V166uU\" data-toggle=\"modal\" data-target=\"#videoModal\"&gt; &lt;i class=\"fas fa-play fa-3x\"&gt;&lt;/i&gt;&lt;!--data-toggle 通常會伴隨一個icon，告知系統在點擊後會觸發另一個行動 --&gt; &lt;/a&gt; &lt;h1&gt;Watch Our Publicity Film&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 進階效果設定 box-shadow陰影效果，也能在chrome內建工具進行細部調整 filter效果brightness是可以調整亮度 transform: scale(1.2) //指定元素由參考點縮放 m 倍 參考網站: filterCSS属性 濾鏡效果製造器","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/CSS/"}]},{"title":"CSS_絕對/相對定位","slug":"1027","date":"2019-10-26T16:00:00.000Z","updated":"2020-05-13T10:18:33.208Z","comments":true,"path":"2019/10/27/1027/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2019/10/27/1027/","excerpt":"","text":"absolute 元素的定位是在他所處上層容器的相對位置 如果沒有寫relative對應，則會依照瀏覽器預設的寬高為基準 若要頁面「並排」可使用float，「重疊」可用相對定位語法 單獨使用relative及absolute的解析 單設定一組absolute，會以body裡為範圍做位置上的移動，因此在設定一組absolute前，我們w通常會需要先新增一組relative當作外框架的基準，才能在目前的區塊去做移動而不是整個大body 單設定一組relative，則box會以class目前所在的位置做移動(top:20px) 設定重疊順序z-indexbox1: z-index=2box2: z-index=1結果：box1會重疊在box2區塊上方","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/CSS/"}]},{"title":"CSS_區塊元素與行內元素","slug":"1028","date":"2019-10-26T16:00:00.000Z","updated":"2020-05-13T10:39:50.646Z","comments":true,"path":"2019/10/27/1028/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2019/10/27/1028/","excerpt":"","text":"區塊元素(block) 在新的一行開始 若沒有定義該元素長寬，則會100%佔滿所在空間 例：會佔滿整個區塊(整行) css語法：display:block; 12345678區塊元素常見包括div、p、h1~h6、ul、ol、li、dl、dt、dd、form、table、hr、blockquote 、address、menu、pre.....等等 行內元素(inline) 不一定會在新的一行開始 該元素佔有的空間為其內容本身(文字或圖片)之長寬 無法重新自定義長寬 可能其他元素並排(視空間寬度而定) 例：span會接續前方元素，不會換行 123456行內元素常見包括span、em、i、b、strong、a、img、input、br、select、textarea、q、bdo、sub、sup 空元素特點1.没有内容的 HTML 元素被稱為空元素。空元素是在開始標籤中關閉的。2.由於HTML元素的内容是開始標籤与结束標籤之间的内容。 而某些HTML元素具有空内容。那些含有空内容的HTML元素，就是空元素。3.單標籤，只有開始標籤，没有结束標籤 空元素常見包括 123&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;&lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt;...等等 More info: 參考連結","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/CSS/"}]},{"title":"CSS_遮罩層overlay效果","slug":"1029","date":"2019-10-26T16:00:00.000Z","updated":"2020-05-13T10:48:39.406Z","comments":true,"path":"2019/10/27/1029/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2019/10/27/1029/","excerpt":"","text":"使用overlay通常是要上層壓字，使文字能更清楚呈現，下圖為遮罩效果的差異 範例圖樣 123456789101112131415&lt;section id=\"video-play\"&gt; &lt;div class=\"dark-overlay\"&gt; &lt;!-- 背景暗色 --&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt; &lt;div class=\"container p-5\"&gt;&lt;!-- padding --&gt; &lt;a href=\"#\" class=\"video\" data-video=\"https://www.youtube.com/embed/SjJ08V166uU\" data-toggle=\"modal\" data-target=\"#videoModal\"&gt; &lt;i class=\"fas fa-play fa-3x\"&gt;&lt;/i&gt;&lt;!--data-toggle 通常會伴隨一個icon，告知系統在點擊後會觸發另一個行動 --&gt; &lt;/a&gt; &lt;h1&gt;Watch Our Publicity Film&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 設定CSS條件 調整背景的opacity透明度 透過相對、絕對定位調整遮罩位置，重疊 12345678910111213141516171819#video-play &#123; position: relative; min-height: 200px; background: url('../img/Video.jpg'); background-attachment: fixed; background-repeat: no-repeat; text-align: center; color: #fff;&#125;.dark-overlay &#123; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); //透明度&#125; 實作Demo: 體育新聞網站","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/CSS/"}]},{"title":"CSS_圖解flex的容器位置","slug":"1025","date":"2019-10-24T16:00:00.000Z","updated":"2020-05-13T10:05:50.162Z","comments":true,"path":"2019/10/25/1025/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2019/10/25/1025/","excerpt":"","text":"容器之內的物件可並行接續排列，並且每個物件都有固定比例占據該容器 外層容器的display屬性為flex 在內層物件中，各自定義佔據的寬度或剩餘空間的分配比例 為了避免 ==外層容器空間不足== ，可以min-width輔助定義最小的寬度 定義排序方向為「上到下」 定義「自動換行」 調整容器位置的三種方式 justify-content 調整水平方向 align-items 調整垂直方向 align-self 調整內層的垂直方向","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/CSS/"}]},{"title":"HTML_SEO網頁優化(優化Head項目)","slug":"1021","date":"2019-10-20T16:00:00.000Z","updated":"2020-05-13T09:50:07.839Z","comments":true,"path":"2019/10/21/1021/","link":"","permalink":"https://vince-chen-hao.github.io/KnowHao/2019/10/21/1021/","excerpt":"","text":"把Head標籤的關鍵詞布局做好，讓這標籤中的title、keywrods、Description相輔相成，那麼你的網站，在搜尋引擎中將會有個好的開始 Head標籤優化網頁之關鍵詞(keywords)標題優化Keywords中，關鍵詞是頁面關鍵詞，雖然已經被眾多黑帽SEO利用，導致權重下降，但仍然是搜尋引擎關注點之一，Keywords應該限制在6-8個關鍵詞。 Head標籤優化網頁之描述Description優化Description中，對於關鍵詞的作用明顯降低，但由於很多的搜尋引擎，仍然大量採用網頁的META標籤中的描述部分作為搜索結果的「內容摘要」，Description不僅對我們的網站的排名有很大的作用，更加對如有銷售目的是十分重要的，好的Description不僅吸引搜索者點擊，更加會促進網站的轉化率。 Head可優化項目123456789101112131415161718&lt;link rel=\"shortcut icon\" href=\"favicon.ico\"&gt;&lt;meta name='description' content='網站描述文字' /&gt;&lt;meta name=\"application-name\" content='品牌名稱' /&gt;&lt;meta name=\"keywords\" content='網站關鍵字' /&gt;&lt;meta property=\"og:title\" content=\"FB的標題\" /&gt;&lt;meta property=\"og:description\" content=\"FB的描述\"&gt;&lt;meta property=\"og:type\" content=\"website\" /&gt;&lt;meta property=\"og:url\" content=\"FB上的網址\" /&gt;&lt;meta property=\"og:image\" content=\"FB的圖片\" /&gt;&lt;link href=\"圖片路徑\" rel=\"apple-touch-icon\" /&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\" /&gt;&lt;link rel=\"stylesheet\" href=\"CSS檔案路徑\"&gt;&lt;script type=\"text/javascript\" src=\"JS檔案路徑\"&gt;&lt;/script&gt; More info: Head進階資訊設定","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/HTML/"}]}],"categories":[],"tags":[{"name":"前端文","slug":"前端文","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/%E5%89%8D%E7%AB%AF%E6%96%87/"},{"name":"教學文","slug":"教學文","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/%E6%95%99%E5%AD%B8%E6%96%87/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/Vue/"},{"name":"ES6","slug":"ES6","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/ES6/"},{"name":"Webpack","slug":"Webpack","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/Webpack/"},{"name":"Git","slug":"Git","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/Git/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/Bootstrap/"},{"name":"CSS","slug":"CSS","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/CSS/"},{"name":"Slick","slug":"Slick","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/Slick/"},{"name":"HTML","slug":"HTML","permalink":"https://vince-chen-hao.github.io/KnowHao/tags/HTML/"}]}