{"meta":{"title":"Vince'Blog","subtitle":"一個抒發本人心情的地方","description":"Do the right thing","author":"Vince","url":"https://vince-chen-hao.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-05-18T07:47:22.000Z","updated":"2020-05-18T07:49:07.967Z","comments":true,"path":"categories/index.html","permalink":"https://vince-chen-hao.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue_過濾API資料(實作)","slug":"0315","date":"2020-03-14T16:00:00.000Z","updated":"2020-05-18T06:36:04.657Z","comments":true,"path":"2020/03/15/0315/","link":"","permalink":"https://vince-chen-hao.github.io/2020/03/15/0315/","excerpt":"＊過濾目標使用者經由選擇器篩選縣市後(如下圖)，跳出選定縣市的藥局資料。 第一步是先將raw data分類出select可以導入的縣市資料庫後，接下來就是進行基本的判定式(if/else)再利用陣列語法(filter)匯入顯示頁面。韓式內容大致是新增一變數，如選擇區域欄位是空的，就回傳與city相同的值，如選擇區域是有資料的，那就回傳與區域相同的。","text":"＊過濾目標使用者經由選擇器篩選縣市後(如下圖)，跳出選定縣市的藥局資料。 第一步是先將raw data分類出select可以導入的縣市資料庫後，接下來就是進行基本的判定式(if/else)再利用陣列語法(filter)匯入顯示頁面。韓式內容大致是新增一變數，如選擇區域欄位是空的，就回傳與city相同的值，如選擇區域是有資料的，那就回傳與區域相同的。 12345678const pharmacies = this.data.filter(pharmacy =&gt; &#123; //data裡的area如沒有資訊，則找出與data裡的city相同的縣市 if (!this.select.area) &#123; return pharmacy.properties.county === this.select.city; &#125; //顯示data裡area區域的資料 return pharmacy.properties.town === this.select.area;&#125;); ＊統整API資料處理的流程以實作過兩個作品的經驗來看，把API取得顯示的過程分為四個步驟，串接、分離、核對、顯示， 串接：javascript有三種方法，請參考API串接語法文章，另外也能使用Vue語法做串接 分離：一般來說，取得的資料量都非常巨大，勢必是要經過拆解，提供選擇項目以供使用者進行篩選，這時碼就必須先動動腦，什麼資料要在頁面可做篩選，決定後再與select選項欄做串連，就實作經驗而言，可以直接在raw data上做一步步的拆解，如：取得唯一值，又或者直接導入外部資料來源，取得select欄位的顯示資料，可參考select串接就能在畫面上篩選資料，並將資料串連至vue的data變數上 核對：這邊就能使用陣列語法(filter、forEach、map)等等去刪選並核對顯示的資料內容，此時就能將整理過的資料傳送到data指定變數上 顯示：經由v-for迴圈，將資料回傳至畫面，除了直接回傳外，有時也會有特別需另外判定的資料，又或者經由Map串接的資料，這都須配合不同的規則去做調整 ＊Vue資料過濾流程(Computed &amp; Methods)選單分類（通常使用Computed） 選項綁定：新增一組字串變數，承接v-model選項的值 資料呈現：是用computed的函式名稱(可當變數) 函式內容：執行filter（代入變數值判定）後回傳給computed函式 執行過程：在頁面選擇項目後(更動變數值)，自動執行filter並回傳 列表分類（Methods） 選項綁定：使用點擊函式，代參數放產品分類名稱 資料呈現：新增一組新陣列放過濾後資料 函式內容：執行filter（代入參數值判定）後回傳給新陣列 執行過程：當點擊函式，將參數載入filter公式，回傳至變數在頁面顯示","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://vince-chen-hao.github.io/tags/Vue/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/tags/JavaScript/"}]},{"title":"Vue_ 口罩地圖(實作)","slug":"0313","date":"2020-03-12T16:00:00.000Z","updated":"2020-05-18T06:35:58.931Z","comments":true,"path":"2020/03/13/0313/","link":"","permalink":"https://vince-chen-hao.github.io/2020/03/13/0313/","excerpt":"執行共分為四步驟 取得 篩選 配對 顯示","text":"執行共分為四步驟 取得 篩選 配對 顯示 取得API資料後（mounted）放置data變數裡，並使用leaflet語法串接地圖 12345678910111213141516171819202122232425mounted() &#123; const url = \"https://raw.githubusercontent.com/kiang/pharmacies/master/json/points.json\"; this.$http.get(url).then(response =&gt; &#123; this.data = response.data.features; console.log(\"&lt;data&gt;\"+JSON.stringify(this.data)); this.updateMarker(); //取得資料後執行更新 &#125;); osmap = L.map(\"map\", &#123; center: [25.03, 121.55], zoom: 16 &#125;); L.tileLayer(\"https://&#123;s&#125;.tile.openstreetmap.org/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png?&#123;foo&#125;\", &#123; foo: \"bar\", attribution: 'Map data &amp;copy; &lt;a href=\"https://www.openstreetmap.org/\"&gt;OpenStreetMap&lt;/a&gt; contributors, &lt;a href=\"https://creativecommons.org/licenses/by-sa/2.0/\"&gt;CC-BY-SA&lt;/a&gt;', maxZoom: 18 &#125;).addTo(osmap); L.marker([25.03, 121.55]).addTo(osmap); &#125;&#125;; 載入台灣城市JSON檔案，匯出Select選擇欄(縣市＋區域) 1234567891011121314151617181920&lt;div class=\"search-bar p-2\"&gt; &lt;div class=\"form-group d-flex\"&gt; &lt;label for=\"city\" class=\"mr-2 col-form-label\"&gt;縣市&lt;/label&gt; &lt;div class=\"flex-fill\"&gt; &lt;select class=\"form-control\" id=\"city\" v-model=\"select.city\" @change=\"select.area = ''\" &gt; &lt;!-- 當選擇其他選項時，就會觸發change裡的指令 --&gt; &lt;option value&gt;-- 請選擇縣市 --&lt;/option&gt; &lt;option v-for=\"item in cityName\" :value=\"item.CityName\" :key=\"item.CityName\" &gt;&#123;&#123; item.CityName &#125;&#125;&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; 123456789101112131415161718&lt;div class=\"form-group d-flex\"&gt;&lt;label for=\"area\" class=\"mr-2 col-form-label\"&gt;地區&lt;/label&gt;&lt;div class=\"flex-fill\"&gt; &lt;select class=\"form-control\" id=\"area\" v-if=\"select.city.length\" v-model=\"select.area\" @change=\"updateSelect\" &gt; &lt;option value&gt;-- 請選擇地區 --&lt;/option&gt; &lt;option :value=\"area.AreaName\" v-for=\"area in cityName.find((city) =&gt; city.CityName === select.city).AreaList\" :key=\"area.AreaName\" &gt;&#123;&#123; area.AreaName &#125;&#125;&lt;/option&gt; &lt;/select&gt;&lt;/div&gt;&lt;/div&gt; 執行filter將Select選擇的區域做配對，媒合後顯示資料 1234567891011methods: &#123; updateMarker() &#123; //取出區域 const pharmacies = this.data.filter(pharmacy =&gt; &#123; //如果data裡的area沒有資訊，則找出與data裡的city相同的縣市 if (!this.select.area) &#123; return pharmacy.properties.county === this.select.city; &#125; //找出與data裡的area相同的區域 return pharmacy.properties.town === this.select.area; &#125;); 緊接著利用forEach匯入地圖座標、顯示藥局資訊等功能 12345678910111213141516171819202122232425//利用forEach執行動作，取得座標＋顯示內容pharmacies.forEach(pharmacy =&gt; &#123;const &#123; properties, geometry &#125; = pharmacy;const icon = properties.mask_adult || properties.mask_child ? icons.orange : icons.grey;&#125;L.marker([ geometry.coordinates[1],geometry.coordinates[0],properties],&#123;icon&#125;) .addTo(osmap).bindPopup(`&lt;h5&gt;$&#123;properties.name&#125;&lt;/h5&gt; 電話： $&#123;properties.phone&#125;&lt;br&gt; 地址：&lt;a href=\"https://www.google.com.tw/maps/place/$&#123;properties.address&#125;\" target=\"_blank\"&gt;$&#123;properties.address&#125;&lt;/a&gt;&lt;br&gt; &lt;small&gt;資料更新時間：$&#123;properties.updated&#125;&lt;/small&gt; &lt;p&gt;備註： $&#123;properties.note&#125;&lt;/p&gt; &lt;hr&gt; &lt;mark&gt;口罩數量：&lt;b&gt;成人&lt;ins&gt; $&#123;properties.mask_adult&#125; &lt;/ins&gt;個 / 兒童 &lt;ins&gt; $&#123;properties.mask_child&#125;&lt;/ins&gt; 個 &lt;/b&gt;&lt;/mark&gt;&lt;br&gt; `);&#125;);//上面執行的forEach是顯示初步取得（select選項）的地圖資訊，而非點擊後的this.penTo(pharmacies[0]); //回傳入第一個藥局進入penTo下方的語法&#125;, 最後一步是將取得資料顯示在頁面上，使用迴圈，並經由v-if判定是否符合縣市與區域的資料，顯示結果就會是select裡選擇的區域資料。 1234567891011121314151617181920212223&lt;ul class=\"list-group text-dark\"&gt;&lt;template v-for=\"(item, key) in data\"&gt; &lt;!-- v-if符合條件才顯示 --&gt; &lt;a class=\"list-group-item\" :key=\"key\" v-if=\"item.properties.county === select.city &amp;&amp; item.properties.town === select.area\" :class=\"&#123; 'mask-highlight': !item.properties.mask_adult &amp;&amp; !item.properties.mask_child&#125;\" @click=\"penTo(item)\" &gt; &lt;div class=\"d-flex align-items-baseline\"&gt; &lt;i class=\"fas fa-hospital-symbol mr-1\" style=\"font-size:18px;color:orange\"&gt;&lt;/i&gt; &lt;div class=\"info_title\"&gt;&#123;&#123; item.properties.name &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"info_address\"&gt; &lt;p class=\"mb-0\"&gt; 地址： &lt;a :href=\"`https://www.google.com.tw/maps/place/$&#123;item.properties.address&#125;`\" title=\"Google Map\" &gt;&#123;&#123; item.properties.address &#125;&#125;&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; leaflet地圖工具Leaflet 是一套適用於各種平台的 JavaScript 地圖繪製工具，可以呈現類似 Google 地圖的效果。要在網頁上呈現地圖，除了大多數人所熟知的 Google 地圖之外，Leaflet 也是一套很不錯的工具，它是一套開放原始碼的輕量級 JavaScript 網頁地圖函式庫，其所呈現的效果與 Google 地圖非常相似，主要的特色是使用簡單、速度快，並且跨平台，許多知名網站（如 GitHub 與 Flickr 等）都是使用 Leaflet 來呈現地圖。 實用功能layerremove: 切換區域時移除舊的指標123456789// 當select切換區域時(@change))，就會觸發移除指標 updateSelect() &#123; osmap.eachLayer(layer =&gt; &#123; if (layer instanceof L.Marker) &#123; osmap.removeLayer(layer); &#125; &#125;); this.updateMarker(); &#125;, panTo：點擊後會移動至指定位置並聚焦放大12345678910penTo(item) &#123; const &#123; properties, geometry &#125; = item; const icon = properties.mask_adult || properties.mask_child ? icons.orange : icons.grey; //panTo的功用是點擊後會移動至指定位置並聚焦放大 osmap.panTo([ geometry.coordinates[1], geometry.coordinates[0], properties ]); openPopup:自動彈跳藥局的“資訊文字”1234567891011121314151617 L.marker([geometry.coordinates[1], geometry.coordinates[0]],&#123;icon&#125;) .addTo(osmap).bindPopup( `&lt;h5&gt;$&#123;properties.name&#125;&lt;/h5&gt; 電話：$&#123;properties.phone&#125;&lt;br&gt; 地址： &lt;a href=\"https://www.google.com.tw/maps/place/$&#123;properties.address&#125;\" target=\"_blank\"&gt;$&#123;properties.address&#125;&lt;/a&gt;&lt;br&gt; &lt;small&gt;資料更新時間：$&#123;properties.updated&#125;&lt;/small&gt; &lt;p&gt;備註：$&#123;properties.note&#125;&lt;/p&gt; &lt;hr&gt; &lt;mark&gt;口罩數量：&lt;b&gt;成人有&lt;ins&gt; $&#123;properties.mask_adult&#125; &lt;/ins&gt;個 / 兒童有 &lt;ins&gt; $&#123;properties.mask_child&#125;&lt;/ins&gt; 個 &lt;/b&gt;&lt;/mark&gt;&lt;br&gt; ` ) .openPopup(); //彈跳鼠標藥局的“資訊文字” //這裡會顯示聚焦後(點擊後會放大)的資訊&#125; 實作成品作品: 口罩搜尋地圖","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://vince-chen-hao.github.io/tags/Vue/"}]},{"title":"jQuery_事件(Events)","slug":"0310","date":"2020-03-09T16:00:00.000Z","updated":"2020-05-18T06:35:47.039Z","comments":true,"path":"2020/03/10/0310/","link":"","permalink":"https://vince-chen-hao.github.io/2020/03/10/0310/","excerpt":"觸發事件函式123$('選擇器').on('事件類型', function()&#123; 任意處理程序&#125;) $()函式的功能是將HTML元素轉換為jQuery特殊元素，經此方法轉換後的HTML元素稱為「jQuery物件」 on()是設定「當某事件發生時，執行某指令」的方法。 第一個參數是「事件類型(Event Type)」：事件觸發的條件 第二個參數是「處理程序(Event Handler)」：事件被觸發後，接著要调用的方法。","text":"觸發事件函式123$('選擇器').on('事件類型', function()&#123; 任意處理程序&#125;) $()函式的功能是將HTML元素轉換為jQuery特殊元素，經此方法轉換後的HTML元素稱為「jQuery物件」 on()是設定「當某事件發生時，執行某指令」的方法。 第一個參數是「事件類型(Event Type)」：事件觸發的條件 第二個參數是「處理程序(Event Handler)」：事件被觸發後，接著要调用的方法。 範例1(更改css色系)當滑鼠移入#typo，接著會執行：透過css樣式修改#typo的顏色 1$('選擇器').css('屬性','值'); css()中所定義的指令是「jQuery方法」，意即「jQuery其js中定義了的css()這個函式」 123456$function()&#123; $('#typo').on('mouseover',function()&#123; $('#typo').css('color','#ebc000') &#125;)&#125; 123456$(function()&#123; $('#typo').css('color','#556A5B'); $('#typo').css('transform','rotate(10deg)') $('#typo .inner').css('opacity',0.5)&#125;) 多個處理程序在.on()方法中的第一個參數「事件類型」被觸發之後，第二個參數「處理程序函式」中可以執行數個個別處理的程序 123456$('選擇器').on('事件類型', function()&#123; 處理1; 處理2; 處理3...;&#125;) 範例2當滑鼠移入#typo，接著會修改#typo的顏色，透過css樣式修改header的背景顏色 1234567$function()&#123; $('#typo').on('mouseover',function()&#123; $('#typo').css('color','#ebc000') ; $('header').css('background-color','#ffffff') &#125;)&#125; 主要的事件類型 jQuery中，大部分的操作都基於HTML DOM，所以必須確定頁面文件已經完全下載好，才能開始執行程式。 當DOM載入後，可執行ready()方法，或者直接寫function()。 12345678910$(document).ready(function() &#123; // 這裡放你要執行的程式碼&#125;);//or$function()&#123; // 這裡放你要執行的程式碼&#125; 統整Jquery動畫效果slide滑動系列 slideUp : 關閉 slideDown ：開啟 slideToggle ：開關 slideToggle（2000）:兩秒呈現 12345$(document).ready(function()&#123; $('.button').click(function(event)&#123; $('.text').slideToggle(2000); &#125;)&#125;); fade淡出效果 fadeOut : 關閉 fadeIn ：開啟 fadeToggle ：開關 12345$(document).ready(function()&#123; $('.button').click(function(event)&#123; $('.text').fadeToggle(); &#125;)&#125;); 鏈式複合式動畫效果連續動畫的效果很吸睛，只需要在slideUp後再新增幾組效果slideDown及slideUp，便可呈現開啟關閉效果。 12345$(document).ready(function()&#123; $('.start').click(function(event)&#123; $('.box').slideUp(1000).slideDown(1000).slideUp(1000); &#125;);&#125;); 延遲出現動畫效果指定區塊後方新增.delay（毫秒）.fadeIn效果 1234567$(document).ready(function()&#123; $('.open').click(function(event)&#123; $('.box1').delay(0).fadeIn(); $('.box2').delay(1000).slideDown(); $('.box3').delay(2000).show(0); &#125;);&#125;); 晃動效果12345$(document).ready(function()&#123; $('.open').click(function(event)&#123; $('.box').addclass('shake') &#125;);&#125;); 另外也『 大推 』 CSS animate動畫工具，請參考 詳細使用說明","categories":[],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://vince-chen-hao.github.io/tags/jQuery/"}]},{"title":"Vue_取得不重複陣列(實作)","slug":"0308","date":"2020-03-07T16:00:00.000Z","updated":"2020-05-18T06:35:38.907Z","comments":true,"path":"2020/03/08/0308/","link":"","permalink":"https://vince-chen-hao.github.io/2020/03/08/0308/","excerpt":"執行用途希望在rawData裡，取出不重複的屬性名稱，為了將縣市名稱傳到選擇欄裡，供使用者選擇想知道的縣市資料，我們可使用Set.prototype.add()取出不重複的屬性名。","text":"執行用途希望在rawData裡，取出不重複的屬性名稱，為了將縣市名稱傳到選擇欄裡，供使用者選擇想知道的縣市資料，我們可使用Set.prototype.add()取出不重複的屬性名。 範例1：取出不重複值123var array = [1, 2, 2, 3, 3, 3];var result = Array.from(new Set(array));console.log(result); // [1, 2, 3] 範例2：取出不重複屬性名注意：如果是以陣列包物件的形式進行new Set，回傳的雖然也是陣列的形式，不過裡頭會是字串的形式呈現，而非是陣列包物件。 123var array = [&#123;碗&#123;....&#125;&#125;, &#123;盤&#123;....&#125;&#125; ,&#123;碗&#123;....&#125;&#125;];var result = Array.from(new Set(array));console.log(result); // ['碗', '盤'] 字串的形式 實作解析目標是透過API取得的未整理資料，因為要在select上顯示各個區域的縣市，將經由new Set公式取得不重複的縣市，順利顯示在選單上，供使用者選取特定縣市。 1234567891011121314data: &#123; data: [], locations: [],&#125;, methods: &#123; getUniqueList() &#123; const newlocations = new Set(); this.data.forEach((item, i) =&gt; &#123; newlocations.add(item.Region) &#125;) this.locations = Array.from(newlocations); &#125; &#125;, 程式碼使用new Set( 含add())、forEach、array.from 多語法處理，需反覆理解。 新增變數newlocations並帶入new Set()語法 此時想取用data的區域資料，利用forEach執行全部的區域，並將取得資料add放入變數裡 此時將newlocation利用Array.from轉成陣列格式匯入到變數locations裡 變數location便取得區域名稱的唯一值 實作成品作品: 口罩搜尋地圖","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://vince-chen-hao.github.io/tags/Vue/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/tags/JavaScript/"}]},{"title":"JavaScript- 陣列處理方式","slug":"0305","date":"2020-03-04T16:00:00.000Z","updated":"2020-05-18T06:35:34.295Z","comments":true,"path":"2020/03/05/0305/","link":"","permalink":"https://vince-chen-hao.github.io/2020/03/05/0305/","excerpt":"陣列使用的技巧是辨別 JavaScript 功力相當重要的一塊，只要能夠對於陣列資料操作熟悉，配合框架就能夠將開發效率更上層樓。","text":"陣列使用的技巧是辨別 JavaScript 功力相當重要的一塊，只要能夠對於陣列資料操作熟悉，配合框架就能夠將開發效率更上層樓。 forEach：單純執行每個陣列內的物件或值。 map：執行每個元素，回傳的值會替代原本陣列內的值。 filter：執行每個元素，回傳 true 時，目前的值會保留在陣列內，這會回傳一個新陣列，而不是修改原本的陣列。 reduce：執行每個元素，依序組合、加總，然後丟給下個元素，最終會回傳一個結果。 forEach()forEach：遍歷每個元素，函式執行每個陣列內的物件或值 123陣列名.forEach(function(數值item ,索引index , 原陣列array)&#123; 執行內容&#125;) 案例12345this.todos.forEach(function(item)&#123; if（item&gt;2）&#123; console.log(item) &#125;&#125;//在this.todos陣列裡，使用item的資料做迴圈判斷 在陣列內新增cash項目，並套用原momey數值+500 1234people.forEach(function(item,index,array)&#123;item.cash = item.money + 500console.log(item)&#125;); map()map與foreach的差異是map會有return指向新的陣列裡，但不影響原陣列的數值，很適合將原始的變數運算後重新組合一個新的陣列。 需產生新的陣列newpeople，放入函數內所新增的變數，*return代表會回傳一個值（滿足條件）到新陣列裡。 1234567const newpeople =people.map(funtion(item,index,array)&#123; return&#123; ...item, //…item表示為陣列裡的所有值，逗號後是結合後方的新變數 icash:item.money+500 &#125;&#125;) filter()按照字面上的意思來說就是過濾器，filter 不會修改值，但他會幫你決定要不要將這個值留在陣列裡面，要注意的是 filter 會回傳一個新的陣列，而不是修改原本的陣列。 相較於map不同的是filter會從原陣列裡篩選原有的數值至新陣列上，而非新增新的變數 12345678910var arr = [1, 2, 3, 4], newArr = [];for(var i = 0; i &lt; arr.length; i++) &#123; if(arr[i] &gt; 2) &#123; newArr.push(arr[i]); &#125;&#125;console.log(newArr); // [3, 4] 1234567var arr = [1, 2, 3, 4];var newArr = arr.filter((val) =&gt; &#123; return val &gt; 2;&#125;)console.log(newArr); // [3, 4] every()every() 可以檢查所有的陣列是否符合條件，這僅會回傳一個值 true or false，可以用來檢查陣列中的內容是否符合特定條件。 123456var ans = array.every(function(item, index, array)&#123; console.log(item, index, array); // 物件, 索引, 全部陣列 return item.age &gt; 10 // 當全部 age 大於 10 才能回傳 true&#125;);console.log(ans); // false: 只要有部分不符合，則為 false some()some() 與 every() 非常接近，都是回傳 true or false，差異僅在 every() 需完全符合，some() 僅需要部分符合。 12345678910ar ans2 = people.some(function(item, index, array)&#123; return item.age &lt; 25&#125;);console.log(ans2); // true: 只要有部分符合，則為 true var ans2 = people.some(function(item, index, array)&#123; return item.age &gt; 25&#125;);console.log(ans2); // false: 全部都不符合則為 false 參考資料: 陣列處理方法、Javascript迴圈函式","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/tags/JavaScript/"}]},{"title":"Vue_Vuex狀態管理","slug":"0303","date":"2020-03-02T16:00:00.000Z","updated":"2020-05-18T06:35:23.752Z","comments":true,"path":"2020/03/03/0303/","link":"","permalink":"https://vince-chen-hao.github.io/2020/03/03/0303/","excerpt":"Vue的組件溝通方式在單純的情況之下，兩個上、下層Vue組件若要進行溝通，會使用： 1. props由上傳下：上層使用 v-bind ，下層用props接到v-bind傳來的屬性資料由下傳上：下層發出$emit事件，上層則用v-on偵聽該事件 2. eventbus若專案更大一些，資料不太可能$emit一層一層慢慢傳上去，上層組件用v-on偵聽到事件並拿到資料之後，又再一層層用props慢慢傳到另一個下層組件，這樣很麻煩也很難維護，所以這種結構複雜的跨組件溝通會使用 eventbus 來傳遞資料。","text":"Vue的組件溝通方式在單純的情況之下，兩個上、下層Vue組件若要進行溝通，會使用： 1. props由上傳下：上層使用 v-bind ，下層用props接到v-bind傳來的屬性資料由下傳上：下層發出$emit事件，上層則用v-on偵聽該事件 2. eventbus若專案更大一些，資料不太可能$emit一層一層慢慢傳上去，上層組件用v-on偵聽到事件並拿到資料之後，又再一層層用props慢慢傳到另一個下層組件，這樣很麻煩也很難維護，所以這種結構複雜的跨組件溝通會使用 eventbus 來傳遞資料。 Vuex狀態管理Vuex 大致上是透過一個 Global state 來儲存整個網站共有的狀態，而其設計概念是由「購買按鈕」組件 commit 一個 Mutation，而這個 Mutation 會改變 State，當 State 被改變時，則會觸發有使用到 State 的「購物車」組件的視覺元件被更新，而這整個觸法的過程是「單向運作」的。 Vuex 跟 eventbus 最主要的差異在於，Vuex 的 Global state 是組件共用的狀態，而非單純儲存在某個組件內部中的狀態。所以本質上，組件與組件之間並沒有溝通，而是透過更新 Global State的狀態，而反應畫面到另外一個組件上。 使用 Vuex 時機 組件之間很上互相溝通：不用Vuex 組件僅需上下傳遞就很夠用：不用Vuex 組件會互相溝通，但情境很固定，次數也很少：Event Bus 組件之間會跨結構傳遞狀態：Vuex 需要全域狀態管理：Vuex vuex 的 Store 中有四大元素: State Mutations Getters Actions 解析彼此關係Actions是指狀態的改變就像是Methods的函式，當State的變數需要做更動時，Actions是無法直接變更的，需經由代理商mutation當作兩者的媒介。 案例：我們可以看到State跟Actions裡的資料完全沒有一點瓜格，都是透過Mutations來連結彼此，逐一解釋三者關聯， 在Mutations裡先命名LOADING為此橋樑的名稱，參數裡載入兩個位置(state預設, actions參數)，以此將兩者串連。 actions也要先命名函式名稱updateLoading，並增加兩個參數，前者是函式內使用的變數，第二則成為payload是傳入mutation裡的參數，內容我們先宣告變數名稱要串連mutations的橋樑名稱，以及順帶將payload參數也傳入即可完成 執行流程：html裡寫入vm.$store.dispatch(‘updateLoading’, true)，內容主要是呼叫action函式名，並且載入參數true，這時action函式就會進行動作，傳入mutations執行並改變state裡的值，也就是status參數。 123456789101112131415161718export default new Vuex.Store(&#123; state: &#123; isLoading: false, &#125;, //操作行為 actions:&#123; updateLoading(context, status) &#123; context.commit('LOADING', status); &#125;, &#125;, //操作狀態 mutations:&#123; LOADING(state, status) &#123; //第二個參數是外部傳入 state.isLoading = status; &#125;, &#125;&#125;); 主頁面使用dispatch將需求傳至action裡，並帶指定參數 1vm.$store.dispatch('updateLoading', true); 如果有要回傳變數，則新增computed裡當作state的接口 1234computed: &#123; cart() &#123; return this.$store.state.cart; &#125;, 存放狀態的 Statestate 是 Vuex.Store 中儲存狀態的物件，裡面就可以存放許多自定義的屬性資料 日後會用到的資料，通常都會事先定義好屬性在 Store 中，即使是空字串、空陣列也沒關係，如果沒有事先定義好，之後就必須要用Vue.set的語法才能在 Store 中新增屬性資料。 12345678910111213141516const store = new Vuex.Store(&#123; state:&#123; count:0, userName:\"\", list:[] &#125;, mutations:&#123; addCount(state)&#123; state.count += 1; &#125;, setLoading(state)&#123; //Store 中還沒有 loading 屬性，所以要用 Vue.set 去新增 Vue.set(state,'loading',false); &#125; &#125;,&#125;); 變更狀態的 Mutations要改變 Store 中的屬性，唯一的方法是透過 Mutation，它的實作方法是在 callBack 函式中，把 state 作為參數傳進去，並在其中重新 assign 值給 state 的屬性。而 mutations 中的操作只能是「同步」操作，不能是非同步操作，如果要非同步操作只能在 actions 中。 12345678910111213141516const store = new Vuex.Store(&#123; state:&#123; count:0, &#125;, mutations:&#123; addCount(state)&#123; state.count += 1; //不得使用非同步操作，如：fetch // fetch(url).then(()=&gt;&#123; // state.count +=1; // &#125;); &#125;, &#125;,&#125;); 取得狀態的 GettersGetter 其實就是 Store 中的 computed 123456789101112131415161718192021const store = new Vuex.Store(&#123; state:&#123; todos:[], &#125;, getters:&#123; itemsNotDone(state)&#123; return state.todos.filter(item=&gt; !item.done).length; &#125;, //將 getters 拿進 getter 中用 itemsDone(state,getters)&#123; return state.todos.length - getters.itemsNotDone; &#125;, //getter 也可以回傳出一個函式 itemWithID(state)&#123; return ((id)=&gt;&#123; return state.todos.filter(item=&gt;item.id===id); &#125;) &#125; &#125;,&#125;); 在組件中要引用 getters 的做法: 123456789101112131415//&lt;script&gt;import &#123;mapStates, mapGetters&#125; from 'vuex';export default &#123; computed:&#123; ...mapStates(['todos']), ...mapGetters(['itemNotDone','itemWithID']), &#125;, methods:&#123; test()&#123; this.itemWithID('123'); &#125;, &#125;,&#125;; 發出指令的 Actions 前面提過，Mutations 裡面的操作只能是同步的，但若要透過「非同步」 的方式改變 State 裡的資料，就必須使用 Actions 來做操作。可是 Action 12345678910111213141516171819202122232425262728293031323334const store = new Vuex.Store(&#123; state:&#123; todos:[], &#125;, mutations:&#123; setTodos(state,todos)&#123; state.todos = todos; &#125; &#125;, actions:&#123; fetchTodos(context,payload)&#123; fetch(url). then(rs =&gt; rs.json()). then(todos=&gt;&#123; context.commit('setTodos',todos); &#125;) &#125;, //context 是一個包含 store 中一切的東西， //可是 context 比 store 還多了一些東西， //所以 context 不等同於 store。 //因為我們只需要用到 context 中的 commit //所以這裡經常會使用到重新解構的語法： fetchTodos(&#123;commit&#125;,payload)&#123; ... .then(todos=&gt;&#123; commit('setTodos',todos); &#125;) ... &#125; &#125;&#125;); 在組件中要引用 actions 的做法: 123456789101112131415161718//&lt;/script&gt;import &#123; mapActions&#125; from Vuex;export default &#123; mounted()&#123; this.$store.dispatch('fetchTodos',&#123;id:2&#125;); &#125;, //或是將傳入 dispatch 的參數包成一個物件的寫法 mounted()&#123; this.$store.dispatch(&#123; type:'fetchTodos',//type 是固定的 key id:2, &#125;); &#125;, methods:&#123; ...mapActions(['fetchTodos']) &#125;&#125;; mapAction語法注意：如果是要帶參數就不可以使用此語法 使用mapAction語法，需在script下新增 1import &#123; mapGetters, mapActions &#125; from 'vuex'; 並在method裡的呼叫語法裡刪除既有的dispatch語法直接改成mapAction支援的格式…mapActions([‘getProducts’]),","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://vince-chen-hao.github.io/tags/Vue/"}]},{"title":"ES6_字串模板","slug":"0227","date":"2020-02-26T16:00:00.000Z","updated":"2020-05-18T06:35:12.470Z","comments":true,"path":"2020/02/27/0227/","link":"","permalink":"https://vince-chen-hao.github.io/2020/02/27/0227/","excerpt":"更新字串模板過去我們撰寫字串的時候都是使用”型態，這種寫法會讓程式碼變得很攏長且難以閱讀，再多行的時候也必須插入反斜線來換行。ES6 借鏡了許多開發工具，可以使用 反引號 來插入一段字串，並且可以使用 ${} 來加入變數或函式，省去一堆 +來做串接。","text":"更新字串模板過去我們撰寫字串的時候都是使用”型態，這種寫法會讓程式碼變得很攏長且難以閱讀，再多行的時候也必須插入反斜線來換行。ES6 借鏡了許多開發工具，可以使用 反引號 來插入一段字串，並且可以使用 ${} 來加入變數或函式，省去一堆 +來做串接。 原生寫法 1const msg = \"I am \"+ age +\" years old\"; ES6寫法 1234const msg = ` I am $&#123;age *2&#125; years old. I have $&#123;brother&#125; brothers and $&#123;sister&#125; sisters.`; 解構陣列12345678910111213141516171819202122// 原始寫法const point = [1,2,3];const x = point[0];const y = point[1];const z = point[2];// ES6作法const point = [1,2,3]const [x,y,z] = point;//只取第一個const [x] = point;//只取第二個，用「，」捨去前面的const[,y] = point//取第一個跟其他的，用「...」代表const[x,...others] = point;//others 代表一個陣列[2,3]//給予預設值，當長度不夠時，會自動補植const[x,y,z,w = 0] = point; 解構物件123456789101112131415161718192021//原始寫法const point =&#123; x:1, y:2, z:3 &#125;;const x = point.x;const y = point.y;const z = point.z;//ES6寫法const &#123; x, y, z&#125; = point;//只取一個值const &#123; x &#125; = point;//只取x跟其他的const &#123; x, ...others&#125; = point//other代表&#123;y:2, z:3&#125;//給予預設值，如果原本point裡面沒有值，就會給它預設值const &#123; x=0, w=0 &#125; = point;//x還是1, w是0//重新命名const &#123; x:px=0 &#125; = point;//px是1，可是x會是undefined 物件用於函式1234567891011// 原始寫法const point =&#123; x:1, y:2, z:3 &#125;;const draw = point=&gt;&#123; console.log(point);&#125;//解構寫法const draw = (&#123;x,y,z&#125;)=&gt;&#123; draw(point);//印出1 2 3&#125;","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://vince-chen-hao.github.io/tags/ES6/"}]},{"title":"Vue_Eventbus元件橋樑","slug":"0222","date":"2020-02-21T16:00:00.000Z","updated":"2020-05-18T06:35:04.966Z","comments":true,"path":"2020/02/22/0222/","link":"","permalink":"https://vince-chen-hao.github.io/2020/02/22/0222/","excerpt":"使用時機在 Vue 框架的核心概念中，會盡可能將資料數據與 UI 封裝成可重複使用的組件，然而，當涉及組件與組件之間的資料交互傳輸時，就需要用到組件溝通的工具。 一般常用的父、子層組件溝通，會使用 props 、 $emit 來傳收資料；可是多個組件需要共用一種狀態時，就會需要使用到全域狀態管理的 Vuex。可是有時候情況只是兄、弟層組件溝通，沒有那麼複雜需要用到 Vuex ，就可以使用 EventBus。","text":"使用時機在 Vue 框架的核心概念中，會盡可能將資料數據與 UI 封裝成可重複使用的組件，然而，當涉及組件與組件之間的資料交互傳輸時，就需要用到組件溝通的工具。 一般常用的父、子層組件溝通，會使用 props 、 $emit 來傳收資料；可是多個組件需要共用一種狀態時，就會需要使用到全域狀態管理的 Vuex。可是有時候情況只是兄、弟層組件溝通，沒有那麼複雜需要用到 Vuex ，就可以使用 EventBus。 元件如何掛載？又如何彼此溝通?元件用法又分為兩種，一種只是圖型呈現，就只需要搭載至主頁面中就可以，另一種是需要呼叫主頁面裡的變數、函式，就需要用到emit及props呼叫，bus也是同一類型。 第一種元件：單純呈現template 123456789101112131415&lt;template&gt; &lt;div&gt; &lt;Navbar/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Navbar from './Navbar'export default &#123; components:&#123; Navbar, &#125;&#125;&lt;/script&gt; 第二種元件：需使用主頁面的變數及函式 變數使用props，函式使用emit，除了跟上圖一樣啟用載入元件路徑之外，還需要在載入對應的變數及函數(如下圖)，例如：頁籤 1&lt;Pagination :A=\"pagination\" @B=\"getProducts\" &gt;&lt;/Pagination&gt; 第三種元件：當觸發事件後，在元件內會進行函式運算 無須啟用圖一的載入元件路徑，只需在接口處註冊新增bus.on(自定義名稱A) 123456789created() &#123; this.getCart(); const vm = this; vm.$bus.$on('updateCart',()=&gt;&#123; vm.getCart(); &#125;); &#125;, 並再主頁面點擊某種物件時，同時觸發元件A內容，使用bus.emit當作接口回傳至元件內部執行函式裡的內容即可，例如：彈跳提示視窗、包含動態式購物車也要(另需template增加&lt;&gt;項目)。 123this.$http.post(api, cart).then((res) =&gt; &#123; vm.$bus.$emit('updateCart'); this.$bus.$emit('message:push',res.data.message,'success') EventBus簡介在 Vue 中使用 EventBus，就像是所有組件共同的事件中心，組件與組件之間可以上下垂直、左右平行互相溝通。 具體做法是在專案入口檔案，建立一個 Vue 實例(Instance) 作為 EventBus，接著在各個組件之中去引入這個 EventBus，透過分別調用 EventBus 的事件監聽來完成組件之間的資料傳遞。 初始化首先要創建一個 EventBus，有兩種方式： 第一種，直接在 main.js 檔案中初始化，目的是要在 Vue 的原型下掛載 EventBus。 12//main.jsVue.prototype.$EventBus = new Vue(); 第二種，新增一個 eventBus.js 檔案，在其中引入 Vue，並且匯出宣告出來的 Vue 實例。實際上，它是一個不具有 DOM 元素的組件，它僅有 Vue 實例的方法，因此非常輕便。 1234// eventBus.jsimport Vue from \"vue\";export const EventBus = new Vue(); 掛載 EventBus全域掛載：將 eventBus 加入 root實例中的 data 中，讓每個子組件都能夠使用。 123456789101112131415//main.jsimport Vue from \"vue\";import eventBus from \"./eventBus.js\";export default new Vue(&#123; store, //use store i18n, el: '#app', data: &#123; EventBus:eventBus, &#125;, methods: &#123;&#125;, render: (h) =&gt; h(app),&#125;); 發送事件全域 EventBuse：如果是全域掛載的 EventBus 可以在任意組件中，利用 EventBus取得EventBus，再呼叫emit 送出事件並傳遞資料。 123456789101112131415//xxx.vue&lt;script&gt;// ...略 methods:&#123; testFunc()&#123; this.$EventBus.$emit(\"testEvent\",&#123; title:\"Test Event Title\", message:\"This is test event.\" &#125;); &#125; &#125;// ...略&lt;/script&gt; 接收事件全域 EventBuse：可以在任一組件中利用 $on 去監聽，只要監聽事件被觸發，都可以接收到訊息。如果想移除事件的監聽，則使用 $off 不需要添加其他任何參數。記得在組件銷毀之前(beforeDestroy)，清除監聽事件 12345678910111213141516171819//xxx.vue&lt;script&gt;// ...略export default&#123; name:\"xxx\", created()&#123; this.$EventBus.$on(\"testFunc\",event=&gt;&#123; console.log(\"Title:\"+event.title); console.log(\"Msg:\"+event.message); &#125;) &#125;, beforeDestroy()&#123; this.$EventBus.$off(\"testFunc\"); &#125;&#125;// ...略&lt;/script&gt; 統整EventBus 身為一個全域的實例，所有的組件都透過$emit 方法向 EventBus 傳送、更新資料;而其他所有的組件，也同步使用監聽事件 $on 偵測它有沒有發生變化，一但資料數據發生變化，就會獲取 event 其中的資料數據。","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://vince-chen-hao.github.io/tags/ES6/"}]},{"title":"ES6_箭頭函式","slug":"0219","date":"2020-02-18T16:00:00.000Z","updated":"2020-05-18T06:34:57.091Z","comments":true,"path":"2020/02/19/0219/","link":"","permalink":"https://vince-chen-hao.github.io/2020/02/19/0219/","excerpt":"簡化後的箭頭函式123456789101112131415161718192021222324//宣告函式function double(n)&#123; return n*2;&#125;var double = function(n)&#123; return n*2;&#125;//箭頭函示const double = (n)=&gt;&#123; return n*2;&#125;//簡化箭頭函示//如果只有一個參數，可以省略括號const double = n =&gt;&#123; return n*2&#125;//簡化箭頭函示//如果函式本體只有一行，且return一個值，可以省略大括號、returnconst double = n =&gt; n*2&#125;)","text":"簡化後的箭頭函式123456789101112131415161718192021222324//宣告函式function double(n)&#123; return n*2;&#125;var double = function(n)&#123; return n*2;&#125;//箭頭函示const double = (n)=&gt;&#123; return n*2;&#125;//簡化箭頭函示//如果只有一個參數，可以省略括號const double = n =&gt;&#123; return n*2&#125;//簡化箭頭函示//如果函式本體只有一行，且return一個值，可以省略大括號、returnconst double = n =&gt; n*2&#125;) 箭頭裡的ｔｈｉｓ箭頭沒有自己的情境(context)，它內部的context就等於它外面的context，函式在哪裡被宣告函式，它裡面的this就代表被宣告時的環境。 如果，把函式改成箭頭函式，因為宣告函式的環境是global，因此箭頭函式中的this就代表global環境的物件，也就是window，不論用哪種方式執行函式一樣 1234const jump =()=&gt;&#123; console.log(this)//this是window&#125;jump(); 1234567const jump =()=&gt;&#123; console.log(this)//this是window&#125;const a = &#123;&#125;;a.jump = jump;a,jump(); 函式裡的this第一種：直接執行函式，this代表window 1234function jump()&#123; console.log(this);//this是window&#125;jump(); 第二種：函式作為物件的方法來執行，其中的this代表物件本身 1234567function jump()&#123; console.log(this);//this是a&#125;const a = &#123;&#125;;a.jump = jump;a.jump(); 第三種：函式作為DOM的偵聽函式，其中的this代表DOM元件 12345678&lt;button id=\"btn\"&gt;btn&lt;/button&gt;function jump()&#123; console.log(this);//this是 &lt;button id=\"btn\"&gt;btn&lt;/button&gt;&#125;btn.addEventListener(\"click\",jump);","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://vince-chen-hao.github.io/tags/ES6/"}]},{"title":"Vue_ 自訂圖標及標題","slug":"0213","date":"2020-02-12T16:00:00.000Z","updated":"2020-05-18T06:34:47.559Z","comments":true,"path":"2020/02/13/0213/","link":"","permalink":"https://vince-chen-hao.github.io/2020/02/13/0213/","excerpt":"Vue Router 設置每頁 title通常網站不僅有一個網頁，建議每個網頁應當有一個專屬的title，以便管理 step0.在自己專案中的 router.js 或 router/index.js 檔案中(依照個人在專案中的檔案命名及路徑)，確定有引入 vue 及 vue-router","text":"Vue Router 設置每頁 title通常網站不僅有一個網頁，建議每個網頁應當有一個專屬的title，以便管理 step0.在自己專案中的 router.js 或 router/index.js 檔案中(依照個人在專案中的檔案命名及路徑)，確定有引入 vue 及 vue-router 123import Vue from 'vue';import VueRouter from 'vue-router';Vue.use(VueRouter); step1. 加入每個路徑頁面的 meta 資料，且於meta中定義title文字。 1234567891011121314151617181920212223const router = new VueRouter(&#123; routes: [ &#123; path: '/entrance', name: 'entrance', component: Entrance, meta: &#123; title: 'Entrance'&#125; &#125;,&#123; path: '/login', name: 'login', component: Login, meta: &#123; title: 'Login'&#125; &#125;,&#123; path: '/test', name: 'test', component: Test, meta: &#123; title: 'Test'&#125; &#125;]&#125;) step2.使用全域 navigation guards 非同步解析執行：當路徑(router object)前往(to) meta.title 時，瀏覽器的 title 為 meta.title 1234567router.beforeEach((to, from, next) =&gt; &#123; if (to.meta.title) &#123; document.title = to.meta.title &#125; next();&#125;) step3.最後引出該 router 1export default router; 在 vue 專案中變更 title 圖示step1.因為專案會使用 webpack 或 vue-cli 打包，因此將圖片放置根目錄，或是static資料夾中step2.在 html 的 中配置圖片及文字。 123456&lt;head&gt; &lt;title&gt;標題文字&lt;/title&gt; &lt;!--href中的路徑依照專案實際放置圖示的位置。--&gt; &lt;link rel=\"icon\" href=\"./../static/favicon.ico\" type=“image/x-icon&gt; &lt;/head&gt; step3.修改 webpack 配置檔案 12345new HtmlWebpackPlugin(&#123; //... favicon: path.resolve('/static/favicon.ico'), //路徑依照專案實際放置圖示的位置 //...&#125;) step4.重新啟用，並適時清除瀏覽器暫存資料，即可正確圖示畫面","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://vince-chen-hao.github.io/tags/Vue/"}]},{"title":"Vue_ 渲染列表","slug":"0210","date":"2020-02-09T16:00:00.000Z","updated":"2020-05-18T06:34:42.876Z","comments":true,"path":"2020/02/10/0210/","link":"","permalink":"https://vince-chen-hao.github.io/2020/02/10/0210/","excerpt":"v-for把陣列轉換為一組元素將item拿出來當作屬性自訂所需資料在陣列裡，使用動態屬性分別套入不同顏色(css設定)資料匯入的過程新增一組判斷式，當key值為A則顯示紅色，B則顯示藍色，利用動態屬性更改色系這裡與之前案例的內容相同，也是使用:class綁定屬性的顏色(經由css修改)","text":"v-for把陣列轉換為一組元素將item拿出來當作屬性自訂所需資料在陣列裡，使用動態屬性分別套入不同顏色(css設定)資料匯入的過程新增一組判斷式，當key值為A則顯示紅色，B則顯示藍色，利用動態屬性更改色系這裡與之前案例的內容相同，也是使用:class綁定屬性的顏色(經由css修改) 123456789101112131415161718192021222324252627&lt;div id=\"app\"&gt; &lt;ol&gt; &lt;li v-for=\"item in todo\" v-bind:class='item.key'&gt; &#123;&#123;item.date&#125;&#125; &#123;&#123;item.content&#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt;new Vue(&#123; el:'#app', data:&#123; todo:[&#123;key:'first',date:'3/9',content:'學習javascrip'&#125;, &#123;key:'second',date:'3/10',content:'學會vue框架'&#125;, &#123;key:'second',date:'3/11',content:'做作品'&#125;, &#123;key:'second',date:'3/12',content:'準備面試'&#125;] &#125;,&#125;)&lt;style&gt; .first&#123; color:red; &#125; .second&#123; color:green; &#125;&lt;/style&gt; 陣列新增、刪減、排列基本語法 push(ew item)從陣列後面新增 pop()從陣列後面刪減 unshift(new item)從陣列前面新增 shift()從陣列前面刪減 &lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"item in steps\"&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;button @click=\"push\"&gt;Push&lt;/button&gt; &lt;button @click=\"pop\"&gt;Pop&lt;/button&gt; &lt;button @click=\"shift\"&gt;Shift&lt;/button&gt; &lt;button @click=\"unshift\"&gt;Unshift&lt;/button&gt; &lt;/div&gt; new Vue({ el:'#app', data:{ steps:[1,2,3,4,5], }, methods:{ push(){ this.steps.push(this.steps.length+1); }, pop(){ this.steps.pop(); }, shift(){ this.steps.shift(); }, unshift(){ this.steps.unshift(0); }, } }) 用v-for渲染templete每次迴圈需要被render出來的不只一個元素，而是包含多個標籤元素，可以使用templete&gt;，並將v-for指令放在templete標籤中。 &lt;div id=\"app\"&gt; &lt;template v-for='item in header'&gt; &lt;h1&gt;{{item}}&lt;/h1&gt; &lt;hr/&gt; &lt;/template&gt; &lt;/div&gt; new Vue({ el:'#app', data:{ header:['Home','About','Product','Contact'] }, methods:{ } })","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://vince-chen-hao.github.io/tags/Vue/"}]},{"title":"Vue_ 觸發事件","slug":"0206","date":"2020-02-05T16:00:00.000Z","updated":"2020-05-18T06:34:35.000Z","comments":true,"path":"2020/02/06/0206/","link":"","permalink":"https://vince-chen-hao.github.io/2020/02/06/0206/","excerpt":"v-on綁定事件可將原表達式v-on:click=””簡寫為@:click=””","text":"v-on綁定事件可將原表達式v-on:click=””簡寫為@:click=”” &lt;實作&gt;點擊button做來回切換，語法：class=”{‘A效果’：變數}” A效果連結style宣告的效果 變數宣告從data建議變數而來，再經由methods函數做轉換功能(B=!B) 點擊click事件後，啟動將變數轉為true 此時觸發:Class裡的公式rotate，roatate便會套用css寫入的翻轉語法而產生效果 1234567891011121314151617181920212223242526&lt;div class=\"box\" :class=\"&#123;'rotate': isRotate &#125;\"&gt;&lt;/div&gt; &lt;button class=\"btn btn-outline-primary\" @click=\"changeRotate\"&gt; 切換 box 樣式 &lt;/button&gt;&lt;/div&gt; data: &#123; isRotate: false, &#125;, methods: &#123; changeRotate: function() &#123; this.isRotate = !this.isRotate; &#125;, &lt;style&gt; .box &#123; display: block; transition: all .5s; &#125; .box.rotate &#123; transform: rotate(45deg) &#125; &lt;/style&gt; 其他滑鼠事件 mouseover：滑鼠經過 mouseout：滑鼠移出 mousedown:滑鼠點下 mouseup:滑鼠點下後‘放開’ mousemove：滑鼠在其上方移動時 偵聽按鍵事件鍵盤事件 keydown：按鍵被‘按下’時 keyup：按鍵被按下後‘彈起’時 v-on:keydown.enter (當「enter」按鍵被按下時) v-on:keydown.a.prevent(當「a」按鍵被按下時，但a的內容不會被放入input中) 便利的修飾符語法 .prevent：不執行預設效果 .stop：不讓event傳到外層 .self：只執行自己發出的event .once：只執行一次 &lt;div id=\"app\"&gt; &lt;h1&gt;{{num}}&lt;/h1&gt; &lt;button @click.once=\"num+=1\"&gt;+Add &lt;/button&gt; &lt;/div&gt; new Vue({ el:\"#app\", data:{ num:0, }, }) 更多修飾符","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://vince-chen-hao.github.io/tags/Vue/"}]},{"title":"Vue_ 統整判斷式","slug":"0205","date":"2020-02-04T16:00:00.000Z","updated":"2020-05-18T06:37:09.232Z","comments":true,"path":"2020/02/05/0205/","link":"","permalink":"https://vince-chen-hao.github.io/2020/02/05/0205/","excerpt":"v-show v-if是讓程式判斷是否被render出來 v-show是用css控制是否在畫面中顯示(意即套用display: none)，所以該元素在原始碼中有被render出來，只是不在畫面顯示 可以搭配v-if使用，代表裡面的東西是否render出來;但是不能用v-show，因為本身並非一個元素，只是一個模板，無法被顯示處理","text":"v-show v-if是讓程式判斷是否被render出來 v-show是用css控制是否在畫面中顯示(意即套用display: none)，所以該元素在原始碼中有被render出來，只是不在畫面顯示 可以搭配v-if使用，代表裡面的東西是否render出來;但是不能用v-show，因為本身並非一個元素，只是一個模板，無法被顯示處理 12345678910111213141516171819&lt;div id=\"app\"&gt; &lt;input type=\"checkbox\" v-model=\"showRed\"/&gt;red &lt;input type=\"checkbox\" v-model=\"showGreen\"/&gt;green &lt;input type=\"checkbox\" v-model=\"showBlue\"/&gt;blue &lt;h1 v-if=\"showRed\"&gt;I'm Red.&lt;/h1&gt; &lt;h1 v-else-if=\"showGreen\"&gt;I'm Green.&lt;/h1&gt; &lt;h1 v-else-if=\"showBlue\"&gt;I'm Blue.&lt;/h1&gt; &lt;h1 v-else&gt;Non&lt;/h1&gt;&lt;/div&gt;new Vue(&#123; el:'#app', data:&#123; showRed:false, showGreen:false, showBlue:false, &#125;,&#125;) v-else v-else一定要依附在v-if之後，且是同一層的東西 ==如果中間有其他東西，v-else會無效 1234567891011121314151617181920212223&lt;div id=\"app\"&gt; &lt;input type=\"checkbox\" v-model=\"show\"/&gt; &lt;span v-if='show'&gt;隱藏內容&lt;/span&gt; &lt;span v-else&gt;秀出內容&lt;/span&gt; &lt;templete v-if=\"show\"&gt; &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;h3&gt;&#123;&#123;message&#125;&#125;&lt;/h3&gt; &lt;/templete&gt;&lt;/div&gt;&lt;div id=\"app\"&gt; &lt;input type=\"checkbox\" v-model=\"show\"/&gt; &lt;span v-if='show'&gt;隱藏內容&lt;/span&gt; &lt;br/&gt;//錯誤：不得再v-if/v-else插入其他東西，會出錯 &lt;span v-else&gt;秀出內容&lt;/span&gt; &lt;templete v-if=\"show\"&gt; &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;h3&gt;&#123;&#123;message&#125;&#125;&lt;/h3&gt; &lt;/templete&gt;&lt;/div&gt; v-else-ifv-if若有成立，就不會render下面的v-else-if與v-else 12345678910111213141516171819&lt;div id=\"app\"&gt; &lt;input type=\"checkbox\" v-model=\"showRed\"/&gt;red &lt;input type=\"checkbox\" v-model=\"showGreen\"/&gt;green &lt;input type=\"checkbox\" v-model=\"showBlue\"/&gt;blue &lt;h1 v-if=\"showRed\"&gt;I'm Red.&lt;/h1&gt; &lt;h1 v-else-if=\"showGreen\"&gt;I'm Green.&lt;/h1&gt; &lt;h1 v-else-if=\"showBlue\"&gt;I'm Blue.&lt;/h1&gt; &lt;h1 v-else&gt;Non&lt;/h1&gt;&lt;/div&gt;new Vue(&#123; el:'#app', data:&#123; showRed:false, showGreen:false, showBlue:false, &#125;,&#125;) 注意事項v-for與v-if 優先權的比較 v-for的優先權高於v-if，因此當兩者皆出現在同一個元素上時，v-if會隨著v-for重覆執行數次。 建議將v-for與v-if放不同標籤裡。","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://vince-chen-hao.github.io/tags/Vue/"}]},{"title":"ES6_let、const變數","slug":"0203","date":"2020-02-02T16:00:00.000Z","updated":"2020-05-18T06:34:06.717Z","comments":true,"path":"2020/02/03/0203/","link":"","permalink":"https://vince-chen-hao.github.io/2020/02/03/0203/","excerpt":"ES6的變異總體而言，使用 let 與 const 的變數宣告方式，相較於 var 會更為嚴謹，因此建議在開發 ES6 之後的專案，使用let 與 const 作為變數宣吿，除了讓專案更穩定之外，也可以增加程式碼的可讀性。","text":"ES6的變異總體而言，使用 let 與 const 的變數宣告方式，相較於 var 會更為嚴謹，因此建議在開發 ES6 之後的專案，使用let 與 const 作為變數宣吿，除了讓專案更穩定之外，也可以增加程式碼的可讀性。 以下三點解釋： 區塊限制使用 變數「不」提升(hositing) 不允許重複宣告 案例1：let與const是用來宣告區塊裡的變數＊區塊是指程式碼{}的部分。 123456&lt;script&gt; if(2&gt;1)&#123; let a =3 &#125;&lt;/script&gt; 案例2：比較let與Var的差異12345678910var a = 3;var a = 5;//結果會等於5let a = 3;let a = 5;//結果顯示錯誤，因重複宣告變數 var變數會向上提升，如果沒有命名變數也會顯示undefined，而let與const則不會 同個區塊不可重複命名 常數const: 裝入東西(值)之後就上鎖的盒子，之後不可以再更動裡面的值，const 是唯獨變數，不能被修改，當重要檔案不能被變更如url網址，就適合使用唯獨變數。但如果是在陣列[]或者物件{}內仍可以被變更 變數let: 暫時存放值的盒子，盒子是打開的，可以更動裡面的值 let與var的作用域：作用域不一樣，var的作用域在函數 (function) 裡，let的作用域則是在區塊 (block) 裡。 全域變數：在函式作用域(function scope)之外宣告的變數，全域變數在整個程式中都可以被存取與修改。 區域變數：在函式作用域(function scope)內宣告，每次執行函式時，就會建立區域變數再予以摧毀，而且函式之外的所有程式碼都不能存取這個變數。 使用var宣告變數，可用範圍以function為界，function外讀不到值，但如使用區塊語句像if, else, for, while等等區塊語句時，宣告的區域變數仍然可在整段程式碼做存取，這並不是我們希望的結果，這時候就會建議使用let宣告。","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://vince-chen-hao.github.io/tags/ES6/"}]},{"title":"Webpack_建置工具","slug":"0202","date":"2020-02-01T16:00:00.000Z","updated":"2020-05-18T06:33:59.795Z","comments":true,"path":"2020/02/02/0202/","link":"","permalink":"https://vince-chen-hao.github.io/2020/02/02/0202/","excerpt":"介紹建置工具過去：早期前端工程師寫網頁，僅透過前端三大元素「JavaScript、CSS、HTML」開發web應用。 現今：近年前端發展出許多新思維，出現了「模組化」的概念、「新框架」的出現、「新語言」的誕生，讓傳統的作法不再流行，各種可以加強開發效率的新工具出現。","text":"介紹建置工具過去：早期前端工程師寫網頁，僅透過前端三大元素「JavaScript、CSS、HTML」開發web應用。 現今：近年前端發展出許多新思維，出現了「模組化」的概念、「新框架」的出現、「新語言」的誕生，讓傳統的作法不再流行，各種可以加強開發效率的新工具出現。 模組化：模組化是將一個複雜的系統，分解為多個模組以方便程式開發。例：ES6模組化是國際標準組織ECMA提出的JavaScript模組化標準，他在語言層面上實現模組化，成為瀏覽器和伺服器通用的模組化解決方案。 新框架：在web應用變的龐大時，直接操作DOM會使程式變得複雜難以維護，因此出現React、Vue、Augular前端框架。 新語言：ES6、TypeScript、Flow、SCSS… 然而，前端技術發展之快，卻有一個共同點：這些工具的原始碼無法直接執行，必須透過「轉換」才可以正常執行，因此，「建置工具」就誕生了。 建置工具實際任務「建置」就是將原始程式碼，轉換成可以執行的JavaScript、CSS、HTML。「建置」的目的最主要就是工程化、自動化。 程式轉換：將TypeScript編譯為JavaScript，將SCSS編譯為CSS。 檔案最佳化：壓縮JavaScript、CSS、HTML程式，壓縮合併圖片。 程式分割：分析首頁不需要執行的部分程式，讓其非同步載入。 模組合併：採用模組化建置的專案中的有多個模組、檔案，透過建置功能，將模組合併為一個檔案。 自動更新：監聽本機端程式碼的變動，自動重新建置、更新瀏覽器。 程式驗證：在程式被傳送到倉庫前，需要驗證程式是否符合標準，以及單元測試是否通過。 自動發布：更新程式後，自動建置出現上發布程式，並傳輸給發布系統。 常見的「建置工具」Npm Script：Node.js附帶的套件管理員Grunt：自動化執行依賴的工作Gulp：以串流為基礎的自動化建置工Fis3：整合各種Web開發需要的建置功能Webpack：包裝模組化JavaScript的工具Rollup：專注於ES6的模組包裝工具 Webpack為何物在Webpack裡的所有檔案皆被視為模組，透過Loader轉換檔案，透過Plugin植入鉤子，最後輸出為一個由「多個模組合成的檔案」。所以一個專案中的所有檔案，包含JavaScript、CSS、SCSS、圖片、範本，在經過Webpack的處理，最後會輸出為瀏覽器可以使用的靜態資源。 webpack幫我們做的事情很簡單，就是幫我們編譯我們的Preprocess成瀏覽器看得懂的內容然後打包成一包的完成檔案然後拿去server上傳上去。 webpack 把「任何資源」都視成一個模組。圖片是模組，所以你可以 import Image from ‘./assets/banner.png’；CSS 是模組，你可以 import styles from’style.css’，只要是任何資源都可以 import 進來使用。 使用模組化，避免載入順序引發錯誤的訊息 如使用框架開發，如Vue、react，仍建議使用原框架的CLI 相依性高才建議使用webpack模組化，例如在開發SPA就很適用，則js都是獨立時不太建議使用。 Webpack安裝方式請參考Mike影片有詳盡解說","categories":[],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"https://vince-chen-hao.github.io/tags/Webpack/"}]},{"title":"Vue_ 解析Props、 emit","slug":"0129","date":"2020-01-28T16:00:00.000Z","updated":"2020-05-18T06:33:53.359Z","comments":true,"path":"2020/01/29/0129/","link":"","permalink":"https://vince-chen-hao.github.io/2020/01/29/0129/","excerpt":"vue 組件，會使用 props 來接受上層傳來的資料。props 是一個陣列，裡面包含多個字串。將原本在底下新增的元件移置到新的vue頁面上，原本的執行方式是在html裡頭加上的元件，就能顯示出新vue上的功能，而要顯示此功能就需要進行串接的動作，在新的vue元件裡，需要先命名一變數，當主頁面或其他頁面要使用此元件時，只需要完成變數間串接便可使用","text":"vue 組件，會使用 props 來接受上層傳來的資料。props 是一個陣列，裡面包含多個字串。將原本在底下新增的元件移置到新的vue頁面上，原本的執行方式是在html裡頭加上的元件，就能顯示出新vue上的功能，而要顯示此功能就需要進行串接的動作，在新的vue元件裡，需要先命名一變數，當主頁面或其他頁面要使用此元件時，只需要完成變數間串接便可使用 Props用法命名上，假設在 component 中的 props 使用 camelCase、Pascalcase，在 html 模板中引用時，一律使用 kebab-case ，因為會需要先經過瀏覽器解析。 前提是因為元件屬於內層，vue的主頁面是外層，當要從外層傳入內層需要使用Props語法，將元件裡的變數載入，再到html裡做指定的更換，才能將外層的元素(data內資料)載入到元件內，完成串接props: [‘pageProps’], 主頁面串接範例如下： &lt;Pagination :pageprops=\"pagination\" &gt;&lt;/Pagination&gt; *pagination是data裡的變數 總結：在元件內層裡的公式都需要一個變數x，而在主頁面裡取用需要執行的變數A，將此變數名稱A替換變數x的位置(串接完成)，A變數就會到元件內層進行功能渲染，將渲染的成果在主頁面裡自動呈現，以完成的元件的使用。 emit用法此用法則是內層去觸發外層的函式，例如在點擊時舊會使用到，當我們在內層進行元件的編寫時，不僅只使用v-model概念的變數props串接，也會有觸發事件產生(大部分)，因此就會使用emit去觸發主頁面的methods函式內容。 methods: { pageEmit(page) { this.$emit(\"pagenum_emit\", page); } } 在元件內層同樣要在script寫上methods，並需要一個變數y，以上面的例子來看y等同於pageEmit代參數，執行emit語法再更換一組變數z，此變數z就會到主頁面去跟需觸發的事件做串接(更換對應的變數名稱) 主頁面串接如下： &lt;Pagination @pagenum_emit=\"getProducts\"&gt;&lt;/Pagination&gt; *getProducts是函式名稱*注意在html裡要有大小駝峰的用法，建議使用get_products","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://vince-chen-hao.github.io/tags/Vue/"}]},{"title":"Vue_ 元件Component","slug":"0128","date":"2020-01-27T16:00:00.000Z","updated":"2020-05-18T06:33:47.979Z","comments":true,"path":"2020/01/28/0128/","link":"","permalink":"https://vince-chen-hao.github.io/2020/01/28/0128/","excerpt":"定義Vue 應用程式的使用，主要是以 Vue component 元件 所組成，而最上層是以 Root 為主，下面包含 Header, Content 與 side （不同的 component ）。而每個 Component 當中的 data 都會是互相獨立的，使用前端框架的好處在於，很多時候同樣重複的事情，你只需要做一次，就能重複使用，並且在後面的維護上更為方便。","text":"定義Vue 應用程式的使用，主要是以 Vue component 元件 所組成，而最上層是以 Root 為主，下面包含 Header, Content 與 side （不同的 component ）。而每個 Component 當中的 data 都會是互相獨立的，使用前端框架的好處在於，很多時候同樣重複的事情，你只需要做一次，就能重複使用，並且在後面的維護上更為方便。 首先用Vue.component()方法 第一個參數是component的名字(component 命名用全小寫以 dash 分隔) 第二個參數是一個物件，其中用 templete 的字串定義組件的視覺元素(直接定義html的內容) 重點！ component的宣告必須在 vue 實例 new之前！ 原寫法(無使用元件)123456789101112131415&lt;body&gt; &lt;div id=\"app\"&gt; &lt;button @click=\"count++\"&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt; &lt;/div&gt; &lt;/body&gt;var app = new Vue(&#123; el: '#app', data: &#123; count: 0 &#125;&#125;); 元件寫法123456789101112131415161718&lt;body&gt; &lt;div id=\"app\"&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;/div&gt; &lt;/body&gt;Vue.component('button-counter', &#123; data: function () &#123; return &#123; count: 0 &#125; &#125;, template: '&lt;button v-on:click=\"count++\"&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;'&#125;) x-template使用時機若是 template 中的語法太過複雜，會使用 x-template 的方式來改善程式的可讀性。 x-template 的宣告必須在另一個 script元素中，並為其帶上 text/x-template 的類型，然後通過一個 id 將模板引用過去。 123456789101112&lt;script type=\"text/x-template\" id=\"rowCompTemp\"&gt; &lt;tr&gt; &lt;td&gt;&#123;‌&#123; person.name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;‌&#123; person.cash &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;‌&#123; person.icash &#125;&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/script&gt;Vue.component('row-comp', &#123; props: ['person'], template: '#rowCompTemp'&#125;) 元件使用方式（全域、區域註冊）Global 全域註冊如果有元件共用的需求，我們會使用Vue.component 語法來註冊一個元件，在註冊全域元件時要給予兩個參數，分別為「組件名稱」及「選項物件」，在下方範例中「組件名稱」為 component-layout ，「選項物件」則為其後的內容。 不過使用全域註冊的缺點是，不管有沒有使用到這個元件，其元件就一定會載入，因此，使用全域註冊會將原本不需要的組件載入進來，整體而言，會拖慢網頁載入的時間。 12345678910111213141516171819&lt;div id=”app”&gt; &lt;component-layout&gt;&lt;/component-layout&gt;&lt;/div&gt;&lt;script&gt;Vue.component(\"component-layout\", &#123; template: `&lt;div&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt;`, data()&#123; return&#123; text:'我是全域註冊' &#125; &#125;&#125;);let vm = new Vue(&#123; el: \"#app\"&#125;);&lt;script&gt; Local 局部註冊如同前面所提，考量全域註冊的缺點，某些特定元件就會用區域註冊的方式，註冊在需要使用它的元件之中，同時，它是一個選項物件，可以由 components 這個選項物件屬性載入 Vue 實例 使用。 123456789101112131415161718192021&lt;div id=”app”&gt; &lt;component-layout&gt;&lt;/component-layout&gt;&lt;/div&gt;&lt;script&gt;let vm = new Vue(&#123; el: \"#app\", components:&#123; 'component-layout' :&#123; template: `&lt;div&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt;`, data()&#123; return &#123; text:'我是局部註冊' &#125; &#125; &#125; &#125;&#125;);&lt;script&gt;","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://vince-chen-hao.github.io/tags/Vue/"}]},{"title":"Vue_生命週期","slug":"0125","date":"2020-01-24T16:00:00.000Z","updated":"2020-05-18T06:33:42.733Z","comments":true,"path":"2020/01/25/0125/","link":"","permalink":"https://vince-chen-hao.github.io/2020/01/25/0125/","excerpt":"","text":"第一階段：Creation 初始建置Creation 階段是組件中運行的第一個 Hook 函式，與其他階段不同，它是在伺服器端渲染期間運行。因此，若需要在客戶端渲染和伺服器渲染期間於元件當中設置事件，須於此階段進行設定。 beforeCreate：Vue實例 初始化。 created：Vue實例 建立完成。資料 $data 已可取得，但 $el 屬性尚未被建立。 第二階段：Mounting 資料掛載接續上一個 Creation 階段，首先他會先判斷是否有無 $el 屬性，若沒有則會嘗試另一種掛載方式（使用$mount掛載el）。再來會判斷是否有 $template 屬性 ，若有則直接使用 render function ，反之則使用 $el teamplate 進行模板編譯。 beforeMount：執行元素掛載之前，代表 $el 尚未被建立。 mounted：元素已掛載， $el 被建立，是最常使用的生命週期 hook 補充：若要操作 AJAX，須於 created Hook階段後才能使用，但通常到 mounted Hook 階段，也就是現在才會被使用，屆時，也代表資料已掛載成功。 第三階段：Updating 重新渲染畫面當元件的資料屬性發生變動，或其他因素導致畫面需要重新渲染時，則會調用 Updating 刷新網頁內容。 beforeUpdate：當資料改變被呼叫使用，還不會渲染 View。 updated：當資料更新完成，則驅動 DOM 元素重新渲染畫面 View。 第四階段：Destruction 銷毀當呼叫 destroy 函式時，則會執行銷毀的動作，將原始的元件從 DOM 元素中移除。 beforeDestroy：Vue實例還可使用。 destroyed：Vue實例銷毀，所有的DOM 元素綁定被解除、移除偵聽事件、Vue child 實例也被一併銷毀。","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://vince-chen-hao.github.io/tags/Vue/"}]},{"title":"Vue_ MVVM架構說明","slug":"0116","date":"2020-01-23T16:00:00.000Z","updated":"2020-05-18T06:33:18.703Z","comments":true,"path":"2020/01/24/0116/","link":"","permalink":"https://vince-chen-hao.github.io/2020/01/24/0116/","excerpt":"MVVM 是Model-View-ViewModel 的縮寫，它是一種基於前端開發的架構模式，其核心是提供對View 和View Model 的雙向數據綁定，這使得View Model的狀態改變可以自動傳遞給View，這就是所謂的數據雙向綁定。注意Vue非MVVM框架，但MVVM概念影響Vue.js的運作。","text":"MVVM 是Model-View-ViewModel 的縮寫，它是一種基於前端開發的架構模式，其核心是提供對View 和View Model 的雙向數據綁定，這使得View Model的狀態改變可以自動傳遞給View，這就是所謂的數據雙向綁定。注意Vue非MVVM框架，但MVVM概念影響Vue.js的運作。 MVVM 圖解 透過ViewModel將view及model做串連綁定，因此透過在view的變更，後端的資料也會同步更新數值，相較於jQ需寫程式碼去重新匯入view及改變資料的狀態，較為多工，並且需操作畫面上的dom元素， 而Vue是以資料狀態操作畫面 透過DOM裡面的監聽event來控制/影響View Model，然後去修改Model中的資料內容; 當Model中的資料變更，會讓View Model知道，再去修改相對應DOM中的內容","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://vince-chen-hao.github.io/tags/Vue/"}]},{"title":"Git_分支","slug":"0122","date":"2020-01-21T16:00:00.000Z","updated":"2020-05-18T06:33:35.163Z","comments":true,"path":"2020/01/22/0122/","link":"","permalink":"https://vince-chen-hao.github.io/2020/01/22/0122/","excerpt":"分支建立(git branch)分支的好處，就是每一條線都各司其職，做完事後，再將兩條線的功能合併，並部署上線。","text":"分支建立(git branch)分支的好處，就是每一條線都各司其職，做完事後，再將兩條線的功能合併，並部署上線。 原狀態 新增分支接下來，我們想要開始新增新功能，但又不能污染到目前 master 的穩定版本狀態，於是我們新增一個 dev 分支，指令是：git branch dev 切換至分支當我們要切換分支時，指令是：git checkout dev 新增分支上commit再來我們就開始在 dev 上開發，並新增兩個commit。 切換回主狀態接下來我們切換回 master 看它的狀態。指令是：git checkout master &lt;重要&gt;合併分支：讓master吃到dev最新狀態我們目前的狀態是 master 目前的版本比較舊，而 dev 的版本比較新，所以接下來我們要做的事情，就是讓 master 可以吃到 c3、c4 的 commit。 因為目前 master 版本比較舊，你就必須先用 git checkout master 指令，讓 HEAD 移動到 master。 確保有切換後，就可以下此指令：git merge dev此時，master 位置就會在 c4 了。 快轉模式 vs 非快轉模式當你的 HEAD 位置是某個要被 merge branch(dev) 上的初始 commit，就會觸發快轉模式。 但如果在 master 再新增一個 commit 的話，就不會觸發快轉模式。","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://vince-chen-hao.github.io/tags/Git/"}]},{"title":"Git_基本建置指令","slug":"0121","date":"2020-01-20T16:00:00.000Z","updated":"2020-05-18T06:33:27.681Z","comments":true,"path":"2020/01/21/0121/","link":"","permalink":"https://vince-chen-hao.github.io/2020/01/21/0121/","excerpt":"Git 與 Github ？ Git 是一個分散式版本控制軟體，可藉由它產生一個儲存庫( git Repository)。 Github：支援 git 程式碼存取和遠端托管儲存庫的平台服務 關係像是本地端有一個 index.html，但可以放到 dropbox、Google Drive 進行雲端託管","text":"Git 與 Github ？ Git 是一個分散式版本控制軟體，可藉由它產生一個儲存庫( git Repository)。 Github：支援 git 程式碼存取和遠端托管儲存庫的平台服務 關係像是本地端有一個 index.html，但可以放到 dropbox、Google Drive 進行雲端託管 設定基本資料輸入姓名：git config –global user.name “gon”輸入個人的 email：git config –global user.email “gonsakon@gmail.com“查詢 git 設定內容：git config –list Git指令架構圖 123456789初始化數據庫： git init開啟 .git 隱藏檔查詢當前狀態：git status將檔案加入到索引：git add .將索引檔案變成一個更新(commit)：git commit -m “修改內容”觀察 commit 歷史紀錄： git log下載遠端數據庫： git clone 數據庫網址更新遠端數據庫： git push origin master 終端機指令學習輸入「control + 空白」，關鍵字輸入「終端機」","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://vince-chen-hao.github.io/tags/Git/"}]},{"title":"Vue_class動態切換Style(實作)","slug":"0115","date":"2020-01-14T16:00:00.000Z","updated":"2020-05-18T06:33:19.680Z","comments":true,"path":"2020/01/15/0115/","link":"","permalink":"https://vince-chen-hao.github.io/2020/01/15/0115/","excerpt":"實作目的點擊按鈕後的切換物件的型態，可使用判斷式來開關呈現的狀態","text":"實作目的點擊按鈕後的切換物件的型態，可使用判斷式來開關呈現的狀態 執行步驟在data裡新增一個變數以布林值為判斷單位 1234data: &#123; isTransform : false &#125;, 載入style變更box型態 123456789&lt;style&gt;.box &#123; transition: transform .5s;&#125;.box.rotate &#123; transform: rotate(45deg)&#125;&lt;/style&gt; 套用公式 :class=”{‘classname : 判斷式’}” 12345&lt;div id=\"app\"&gt; &lt;div class=\"box\" :class=\"&#123;'rotate':isTransform&#125;\"&gt;&lt;/div&gt; &lt;hr&gt; &lt;button class=\"btn btn-outline-primary\" @click =\"isTransform = !isTransform\" &gt;選轉物件&lt;/button&gt;&lt;/div&gt; isTransform置換的兩種方式 直接將A=!A寫入html，當@click點擊觸發後便會產生true跟false置換 1@click =\"isTransform = !isTransform\" @click後方寫入js函數內，並使用method將A=!A寫入運算內容也可以 1234methods: &#123; changeRotate: function() &#123; this.isRotate = !this.isRotate; &#125;,","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://vince-chen-hao.github.io/tags/Vue/"}]},{"title":"Vue_修飾符","slug":"0108","date":"2020-01-07T16:00:00.000Z","updated":"2020-05-18T06:33:20.585Z","comments":true,"path":"2020/01/08/0108/","link":"","permalink":"https://vince-chen-hao.github.io/2020/01/08/0108/","excerpt":"事件修飾符常用：v-on:click只需在後方新增prevent語法(防止防止頁面上移) 1&lt;a href=\"#\" class=\"btn btn-info\" v-on:click.prevent=\"reversetext\"&gt;","text":"事件修飾符常用：v-on:click只需在後方新增prevent語法(防止防止頁面上移) 1&lt;a href=\"#\" class=\"btn btn-info\" v-on:click.prevent=\"reversetext\"&gt; 按鍵修飾符 v-on == @原寫法：v-on:click=”函數”修飾寫法：@click=”函數” v-blid ==:原寫法：v-blid:href=”link”修飾寫法：:href=”link” Modifiers 修飾符.lazy原本雙向綁定的更新方式是以 input 事件監聽，亦即資料變動即更新，但使用.lazy會改用 change 事件監聽，event trigger 才更新。此時若要新增一個屬性用來計算總共有多少隻家禽，如下： number修飾符將字串轉為數字，在後方加入number即可將輸入的字串轉為數字 1&lt;input type =\"number\" class=\"form-control\" v-model.number=\"age\"&gt; trim緊貼文字當輸入文字夾雜著空格時，使用trim便可以刪去空格，文字便可以相連 1&lt;input type =\"text\" class=\"form-control\" v-model.trim=\"age\"&gt;&gt;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/tags/JavaScript/"}]},{"title":"JS- 範例","slug":"0513","date":"2019-12-31T16:00:00.000Z","updated":"2020-05-18T06:58:23.406Z","comments":true,"path":"2020/01/01/0513/","link":"","permalink":"https://vince-chen-hao.github.io/2020/01/01/0513/","excerpt":"","text":"外部環境參照 More info: Generating","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/tags/JavaScript/"}]},{"title":"Bootstrap：滾動監聽Scrollspy(實作)","slug":"1228","date":"2019-12-27T16:00:00.000Z","updated":"2020-05-18T06:48:51.303Z","comments":true,"path":"2019/12/28/1228/","link":"","permalink":"https://vince-chen-hao.github.io/2019/12/28/1228/","excerpt":"滾動監聽（Scrollspy）插件，即自動更新導航插件，會根據滾動條的位置自動更新對應的導航目標。其基本的實現是隨著您的滾動，基於滾動條的位置嚮導航欄添加.active class。","text":"滾動監聽（Scrollspy）插件，即自動更新導航插件，會根據滾動條的位置自動更新對應的導航目標。其基本的實現是隨著您的滾動，基於滾動條的位置嚮導航欄添加.active class。 使用方法向頂部導航添加滾動監聽行為： 通過data屬性：向您想要監聽的元素（通常是body）添加data-spy=“scroll”。然後添加帶有Bootstrap .nav組件的父元素的ID或class的屬性data-target。為了它能正常工作，您必須確保頁面主體中有匹配所要監聽鏈接的ID的元素存在。 123456789&lt;body data-spy =“ scroll” data-target =“main-nav”&gt;...&lt;div class =“ navbar-example”&gt; &lt;ul class =“ nav nav-tabs”&gt; ... &lt;/ ul&gt;&lt;/ div&gt;...&lt;/ body&gt; 通過JavaScript：您可以通過JavaScript調用滾動監聽，選取要監聽的元素，然後調用.scrollspy()函數： 12345678910111213141516//Init Scrollspy$('body').scrollspy(&#123; target:'#main-nav'&#125;);//Smooth Scrolling$('#main-nav a').on('click',function(event)&#123; if(this.hash !==\"\")&#123; event.preventDefault(); const hash = this.hash; $('html,body').animate(&#123; scrollTop: $(hash).offset().top &#125;, 700, function()&#123; window.location.hash = hash; &#125;) &#125;&#125;) 實作Nav監聽: 一頁式官網","categories":[],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://vince-chen-hao.github.io/tags/Bootstrap/"}]},{"title":"JavaScript- JSON公開資料","slug":"1226","date":"2019-12-25T16:00:00.000Z","updated":"2020-05-18T06:48:47.384Z","comments":true,"path":"2019/12/26/1226/","link":"","permalink":"https://vince-chen-hao.github.io/2019/12/26/1226/","excerpt":"JSON簡介JSON(全名JavaScript Object Notation)是受到JavaScript物件實體語法啟發的傳輸格式，比起使用XML傳輸資料，JSON格式在檔案大小上更為輕量，也是現在主流的傳輸格式。","text":"JSON簡介JSON(全名JavaScript Object Notation)是受到JavaScript物件實體語法啟發的傳輸格式，比起使用XML傳輸資料，JSON格式在檔案大小上更為輕量，也是現在主流的傳輸格式。 就是 JavaScript Object Notation，JavaScript 物件表示法 JSON 為 純文字 格式 JSON 具自我描述性、易於人理解、閱讀和編寫，同時也易於機器解析和生成 JSON 較 XML (eXtensible Markup Language) 小、快且更易解析 JSON格式JSON 字串可以包含 物件 (Object) 和 陣列 (Array)Tips: 物件與陣列可互相包含，如：{“array”: [{“object”: “object”}]} JSON格式轉換的兩種語法*Stringify(): 將物件序列化成 JSON 字串一般來說，如果要用JSON格式來溝通，都要將原先是物件(含陣列)格式轉成JSON看得懂的字串格式，這種情況就可以使用stringify()物件轉字串，再傳至後端處理。 1234567891011121314151617181920212223// 宣告一個 user objectlet user = &#123; \"name\": \"OAwan\", \"sex\" : \"Male\", \"age\" : 27, \"married\" : false, \"skills\" : [ \"RubyOnRails\", \"JavaScript\", \"Scss\" ]&#125;console.log( JSON.stringify(user, [\"name\", \"sex\"], 2););/* 輸出：&#123; \"name\":\"OAwan\", \"sex\":\"Male\"&#125;*/ *Parse(): 將 JSON 字串解析成 JavaScript 物件從後端處理過後或者是網路上取得的JSON格式，如要經過JS處理呈現在網頁上，此時就可以用parse（）轉成JS看得懂的物件格式。 1234567891011121314151617181920212223// 宣告一個 JSON 字串let userJSON = `&#123; \"name\":\"OAwan\", \"sex\":\"Male\", \"age\":\"27\", \"married\":\"未婚\", \"skills\":[ \"RubyOnRails\", \"JavaScript\", \"Scss\" ]&#125;`;// 透過 JSON.parse() 解析 JSON 字串let user = JSON.parse(userJSON);// 取得物件值console.log( user.name + ', ' + user.skills[1]);/* 輸出：OAwan, JavaScript*/ 實作練習假設我們從後端接到一個JSON字串格式 1'&#123;\"name\":\"Simon\",\"isF2E\":\"true\"&#125;' 使用AJAX接到此JSON格式後，現在想要取當中的name來渲染至頁面上 12var data = '&#123;\"name\":\"Simon\",\"isF2E\":\"true\"&#125;';console.log(data.name+'挑戰第14天') 因為JSON被引號包著，現在是字串格式，這時JSON.parse()就派上用場 1234var data = '&#123;\"name\":\"Simon\",\"isF2E\":\"true\"&#125;'var data2 = JSON.parse(data);console.log(data2.name+'挑戰第14天') 結果顯示”Simon”挑戰第14天，順利取得資料","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/tags/JavaScript/"},{"name":"JSON","slug":"JSON","permalink":"https://vince-chen-hao.github.io/tags/JSON/"}]},{"title":"JavaScript- 三種Ajax串接方式","slug":"1225","date":"2019-12-24T16:00:00.000Z","updated":"2020-05-18T06:48:43.058Z","comments":true,"path":"2019/12/25/1225/","link":"","permalink":"https://vince-chen-hao.github.io/2019/12/25/1225/","excerpt":"第一種：XMLHttpRequest其一老式做法 ── XMLHttpRequest格式：‘get’(讀取資料)、‘post’(傳送資料至該資料庫)","text":"第一種：XMLHttpRequest其一老式做法 ── XMLHttpRequest格式：‘get’(讀取資料)、‘post’(傳送資料至該資料庫) 1234567var xhr = new XMLHttpRequest();xhr.open('get','URL',true);xhr.send(null); //傳送資料（若上面使用'get'，則此欄填寫空值 null ）xhr.onload = function () &#123; data = JSON.parse(xhr.responseText); console.log(`已經載入 api `)&#125; 其中第五行執行的 data = JSON.parse(xhr.responseText)需要提醒一下，因為 JSON 雖然本身是“陣列包物件”的格式，但資料在傳輸的時候必須轉換成 string(字串)，所以我們在接收到了傳送來的「字串」時，就必須使用 JSON.parse 將其轉換回原本的格式 console可得知的串接狀態xmlHttp5個狀態：var state = xmlHttp.readyState;//可能是0、1、2、3、4 0狀態：剛創建，還沒有調用open()方法; 1狀態：請求開始：調用了open()方法，但還沒有調用send()方法 2狀態：調用完了send()方法了； 3狀態：服務器已經開始響應，但不表示響應結束了！ 4狀態：服務器響應結束！（通常我們只關心這個狀態！！！） 得到服務器響應的狀態碼：var status = xmlHttp.status;//例如為200、404、500 第二種：jQuery- 原語法請參考: jQuery串接影片 123456789$.ajax(&#123; url: 'https://randomuser.me/api/', dataType: 'json', success: function(data) &#123; console.log(data); // 取得的遠端資料 &#125;&#125;); 第三種：jQuery- Fetch語法Fetch與 $.ajax 不同點在於： fetch 會使用 ES6 的 Promise 作回應 then 作為下一步 catch 作為錯誤回應 (404, 500…) 回傳的為 ReadableStream 物件，需要使用不同資料類型使用對應方法，才能正確取得資料物件。 1234567891011fetch('https://randomuser.me/api/', &#123;&#125;) .then((response) =&gt; &#123; // 這裡會得到一個 ReadableStream 的物件 console.log(response); // 可以透過 blob(), json(), text() 轉成可用的資訊 return response.json(); &#125;).then((jsonData) =&gt; &#123; console.log(jsonData); &#125;).catch((err) =&gt; &#123; console.log('錯誤:', err);&#125;); 觀念解析true(預設值) 非同步使用非同步的設定時，我們的程式碼不會等到資料回傳回來，就會開始執行後續程式碼，因為有時候我們撈取的 JSON 檔是一大筆資料，那等我們等一大筆筆資料抓完才去執行後續動作，網頁就會在載入完成之前都卡在那邊，無形中就會浪費許多時間成本，因此若要執行非同步，則需另設定一組函式來判定onload狀態，當onload完成後即可取得資料。 false 同步會等資料回傳(接收)完畢，才繼續往下跑","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/tags/JavaScript/"}]},{"title":"JavaScript- AJAX執行概念","slug":"1224","date":"2019-12-23T16:00:00.000Z","updated":"2020-05-18T06:48:39.447Z","comments":true,"path":"2019/12/24/1224/","link":"","permalink":"https://vince-chen-hao.github.io/2019/12/24/1224/","excerpt":"AJAX執行三步驟 取槍：產生一個XMLHttpRequest 上膛：取得要讀取的網址，get(讀取資料)、傳送資料到伺服器 擊發：傳送send 回膛：回傳資料到瀏覽器","text":"AJAX執行三步驟 取槍：產生一個XMLHttpRequest 上膛：取得要讀取的網址，get(讀取資料)、傳送資料到伺服器 擊發：傳送send 回膛：回傳資料到瀏覽器 步驟一（取槍）：產生一個XMLHttpRequest1234var xhr = new XMLHttpRequest();xhr.open('get','https://vince.project/data.json',ture)xhr.send(null); 我們可以經由console得知現在哪個階層 0 - 產生XMLHttpRequest，但沒有連結要撈取的資料 1 - 使用Open()，未傳送資料 2 - 偵測到有send指令 3 - loading 4 - 完成取得資料 步驟二（上膛）：取得要讀取的網址，get(讀取資料)、傳送資料到伺服器1xhr.open(‘get’,‘https://vince.project/data.json’,ture) 同步與非同步定義 true非同步：不會等資料傳回，就讓程式繼續往下跑，等到回傳才會自動回傳，如果載入的資料量入過大，不可能等到資料全部上傳後才顯示程式，因此仍會使用true。 false同步：等資料傳回來之後才會讓程式碼繼續往下跑 我們可以使用onload事件，確定資料有回傳之後才執行函數內容 1234567xhr.onload = function()&#123; console.log(xhr.responseText) //顯示資料訊息 var str = JSON.parse(xhr.responseText); //將回傳資料傳到瀏覽器-字串轉陣列：JSON.parse() document.querySelector('.message') //HTML的文字訊息 class=\"message\" .textContent = str[0].name //將要抓取的資料顯示於頁面&#125; !!!需注意CORS 跨網域撈取資料一般來說跨網域需要詢問對方有沒有開啟CORS，開啟才有辦法抓取資料，取得API也是相似，ex.高雄市公開json資料便沒有開啟此功能。可使用偵測網址查閱狀態：http://test-cors.org/","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/tags/JavaScript/"}]},{"title":"JavaScript_定義全域環境","slug":"1222","date":"2019-12-21T16:00:00.000Z","updated":"2020-05-18T06:48:35.535Z","comments":true,"path":"2019/12/22/1222/","link":"","permalink":"https://vince-chen-hao.github.io/2019/12/22/1222/","excerpt":"一旦執行JavaScript程式， 程式碼都是在執行環境（execution context）裡面建立和執行。(執行環境：一個wrapper，把正在執行的程式碼包在執行環境裡面。)","text":"一旦執行JavaScript程式， 程式碼都是在執行環境（execution context）裡面建立和執行。(執行環境：一個wrapper，把正在執行的程式碼包在執行環境裡面。) 然而相較於執行環境，另外有一個基礎執行環境(base execution context)，又稱做全域執行環境。 全域(Global)‘Global’ means ‘not inside a function’簡而言之，當程式碼或變數不再函式中，就是全域的。 全域環境在全域執行環境中，JavaScript會自動創造兩個東西： Global Object：全域物件 this：一個特殊的變數 全域物件「全域物件」，可以在任何地方被取用。 this變數在沒有寫任何程式碼的情況之下，啟用window瀏覽器執行，這時候全域執行環境中會自動產生一個全域物件-window物件，以及this這個特殊變數。 同一個瀏覽器，開啟另一個分頁，就會創建另外一個全域執行環境，也會獨立產生一個全域物件及this變數。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/tags/JavaScript/"}]},{"title":"Bootstrap_影片彈出視窗(實作)","slug":"1219","date":"2019-12-18T16:00:00.000Z","updated":"2020-05-18T06:48:31.718Z","comments":true,"path":"2019/12/19/1219/","link":"","permalink":"https://vince-chen-hao.github.io/2019/12/19/1219/","excerpt":"目的：點擊影片後顯示彈出視窗，並自動播放影片內容","text":"目的：點擊影片後顯示彈出視窗，並自動播放影片內容 設置HTML樣板 12345678910111213141516 &lt;!-- VIDEO PLAY --&gt;&lt;section id=\"video-play\"&gt; &lt;div class=\"dark-overlay\"&gt; &lt;div class=\"container p-5\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt; &lt;a href=\"#\" class=\"video\" data-video=\"https://www.youtube.com/embed/SjJ08V166uU\" data-toggle=\"modal\" data-target=\"#videoModal\"&gt; &lt;i class=\"fas fa-play fa-3x\"&gt;&lt;/i&gt;&lt;!--data-toggle 通常會伴隨一個icon，告知系統在點擊後會觸發另一個行動 --&gt; &lt;/a&gt; &lt;h1&gt;Watch Our Publicity Film&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 點擊後開啟Modal互動視窗 1234567891011121314&lt;!-- VIDEO MODAL --&gt;&lt;div class=\"modal fade\" id=\"videoModal\"&gt; &lt;!--點擊後淡化原視窗背景顏色 --&gt; &lt;div class=\"modal-dialog\"&gt;&lt;!-- 影片左右置中進行--&gt; &lt;div class=\"modal-content\"&gt; &lt;div class=\"modal-body\"&gt; &lt;button class=\"close\" data-dismiss=\"modal\"&gt;&lt;!--關閉鈕 --&gt; &lt;span&gt;&amp;times;&lt;/span&gt; &lt;/button&gt; &lt;iframe src=\"\" frameborder=\"0\" height=\"350\" width=\"100%\" allowfullscreen&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 套用JQ影片播放語法 1234567891011121314// Video Play$(function () &#123; // Auto play modal video $(\".video\").click(function () &#123; var theModal = $(this).data(\"target\"), videoSRC = $(this).attr(\"data-video\"), videoSRCauto = videoSRC + \"?modestbranding=1&amp;rel=0&amp;controls=0&amp;showinfo=0&amp;html5=1&amp;autoplay=1\"; $(theModal + ' iframe').attr('src', videoSRCauto); $(theModal + ' button.close').click(function () &#123; $(theModal + ' iframe').attr('src', videoSRC); &#125;); &#125;);&#125;); 實作成品彈出式影片: 運動頻道","categories":[],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://vince-chen-hao.github.io/tags/Bootstrap/"}]},{"title":"JavaScript_動態型別","slug":"1218","date":"2019-12-17T16:00:00.000Z","updated":"2020-05-18T06:48:26.676Z","comments":true,"path":"2019/12/18/1218/","link":"","permalink":"https://vince-chen-hao.github.io/2019/12/18/1218/","excerpt":"動態型別在JavaScript中，不需要宣告變數的型別，因為JavaScript是使用「動態型別」在處理變數。僅需要宣告變數(type)，不需要告訴JavaScript變數的型別(type)，它會在執行程式時，自動判別變數的型別，而且一個變數在不同時候可能擁有不同型別。","text":"動態型別在JavaScript中，不需要宣告變數的型別，因為JavaScript是使用「動態型別」在處理變數。僅需要宣告變數(type)，不需要告訴JavaScript變數的型別(type)，它會在執行程式時，自動判別變數的型別，而且一個變數在不同時候可能擁有不同型別。 JavaScript的六種純值(primitive)純值是一種資料型別，代表基本型別，只是一個值，而非物件。 undefinedJavaScript給所有變數的初始值，變數會一直處於undefined，直到程式碼執行到設定變數的值 null表示不存在，可以在程式宣告時，給與該變數的值為null，用以表示該變數沒有值。 boolean表示對或錯，用true或false表示值 Number(數值)在JavaScript中的數值皆為浮點數，不像其他程式語言還會細分整數或其他浮點數等，所以在JavaScript中也可以直接把他假裝為整數。 String(字串)由一連串字符所組成，可以單引號或雙引號表示 Symbal(符號)這是新的型別，被用在ES6中，尚未被全部的瀏覽器支援 強制型轉(Coercion)JavaScript引擎自動將1轉換為字串’1’，才繼續做相加運算，自動避免出錯 12var a = 8 + '7';console.log(a);//87","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/tags/JavaScript/"}]},{"title":"JavaScript_物件傳參考特性","slug":"1215","date":"2019-12-14T16:00:00.000Z","updated":"2020-05-18T06:48:20.923Z","comments":true,"path":"2019/12/15/1215/","link":"","permalink":"https://vince-chen-hao.github.io/2019/12/15/1215/","excerpt":"定義 傳值(Call by value)：在 JavaScript 中的純值 是傳值。(傳過去以後就沒有任何關聯性) 傳參考/傳參照(Call by reference)：傳遞給函式的是它實際參數的隱式參照，而不是實際的拷貝。 傳共用物件(Call by sharing)： a 與 b 是共用同一個物件內容，若 b 修改了物件內容，則 a 也會被修改成同樣內容(物件是共用的，沒有拷貝)。","text":"定義 傳值(Call by value)：在 JavaScript 中的純值 是傳值。(傳過去以後就沒有任何關聯性) 傳參考/傳參照(Call by reference)：傳遞給函式的是它實際參數的隱式參照，而不是實際的拷貝。 傳共用物件(Call by sharing)： a 與 b 是共用同一個物件內容，若 b 修改了物件內容，則 a 也會被修改成同樣內容(物件是共用的，沒有拷貝)。 12345678910111213141516// 傳值var person = '小明'; // 純值var person2 = person;person2 = '杰倫';console.log(perosn, person2)// 小明,杰倫//傳參考var person = &#123; name: '小明'&#125;;var person2 = person;perosn2.name = '杰倫'; // 改變物件內容console.log(perosn, person2);console.log(perosn === person2);// 杰倫,杰倫// true More info: 傳值、傳參考 應對方式：Object.assign 操作測試12345 openModal(item)&#123; //this.tempProduct= item; //因為物件傳參考的特性，直接用item會與tmepProduct相同 this.tempProduct= Object.assign(&#123;&#125;,item); //可採用es6語法，將item傳自獨立的空物件裡，才不會互相渲染&#125;, 無法直接指定匯入變數中，因傳參考的特性會互相渲染，需將item傳入空物件裡才能順利使用。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/tags/JavaScript/"}]},{"title":"CSS_統整display各種屬性","slug":"1212","date":"2019-12-11T16:00:00.000Z","updated":"2020-05-18T06:48:17.134Z","comments":true,"path":"2019/12/12/1212/","link":"","permalink":"https://vince-chen-hao.github.io/2019/12/12/1212/","excerpt":"display: block不論前後元素為何，display:block 元素會直接「換行」開始。&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;、&lt;h2&gt;、&lt;iframe&gt;、&lt;img&gt;這幾個 HTML 元素預設的 display 屬性是 block可以自定義寬高或縮排(margin 、 padding 、 width 、 height 、 background-image 皆「有效」)","text":"display: block不論前後元素為何，display:block 元素會直接「換行」開始。&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;、&lt;h2&gt;、&lt;iframe&gt;、&lt;img&gt;這幾個 HTML 元素預設的 display 屬性是 block可以自定義寬高或縮排(margin 、 padding 、 width 、 height 、 background-image 皆「有效」) display: inlinedisplay : inline 的元素連在一起會在同一行，「不會換行」。要讓 display : inline 元素水平置中的方式是在此元素的父元素加上 text-align : center。&lt;a&gt;、&lt;span&gt;、&lt;b&gt;、&lt;i&gt;、&lt;iframe&gt;、&lt;img&gt;這幾個 HTML 元素預設的 display 屬性是 inline可以針對左右做縮排(margin-left 、 margin-right 、 padding-left 、 padding-right「有效」)上下縮排會失效，且寬高為內容本身寬高，無法自定義寬高。 (margin-top 、 margin-bottom 、 padding-top 、 padding-bottom 、 width 、 height 、 background-image 皆「無效」) display: inline-block內部元素水平排列，而且不需要額外設定clear，也不會讓接著的元素疊上來。可以理解為：外面是inline，裡面是block。所以元素「不會換行」，但是又可以設定元素的padding-top 、 padding-bottom 、 width 、 height 、 background-image 。 display: nonedisplay設為none這個東西就不見了，不佔空間。補充：visibility:hidden是隱形看不見，不過還是有佔空間","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://vince-chen-hao.github.io/tags/CSS/"}]},{"title":"Bootstrap_Lightbox影像燈箱","slug":"1211","date":"2019-12-10T16:00:00.000Z","updated":"2020-05-18T06:48:12.796Z","comments":true,"path":"2019/12/11/1211/","link":"","permalink":"https://vince-chen-hao.github.io/2019/12/11/1211/","excerpt":"主要功能是點選照片，該張照片會以燈箱方式全版展開，提升觀看體驗，請參考Lightbox for Bootstrap進行安裝","text":"主要功能是點選照片，該張照片會以燈箱方式全版展開，提升觀看體驗，請參考Lightbox for Bootstrap進行安裝 結構分為兩層 外層定義燈箱展示的照片，以及展示後的大小 內層定義原始照片 在外層使用bootstrap自定義的data-toggle設定啟用lightbox功能;data-lightbox將多張照片群組起來，在左右切換照片時可以辨識為同一群組的照片 新增程式碼至html裡使data-toggle串連lightbox 123&lt;a href=\"https://unsplash.it/1200/768.jpg?image=250\" data-toggle=\"lightbox\" data-title=\"A random title\" data-footer=\"A custom footer text\"&gt; &lt;img src=\"https://unsplash.it/600.jpg?image=250\" class=\"img-fluid\"&gt;&lt;/a&gt; 最後添加jquery程式碼，避免預設效果，而採用引入的lightbox效果展示 1234$(document).on('click', '[data-toggle=\"lightbox\"]', function(event) &#123; event.preventDefault(); $(this).ekkoLightbox();&#125;); 實作燈箱畫冊: 運動頻道","categories":[],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://vince-chen-hao.github.io/tags/Bootstrap/"}]},{"title":"VsCode- 常用快捷鍵","slug":"1207","date":"2019-12-06T16:00:00.000Z","updated":"2020-05-18T06:48:07.538Z","comments":true,"path":"2019/12/07/1207/","link":"","permalink":"https://vince-chen-hao.github.io/2019/12/07/1207/","excerpt":"以下快捷鍵限支援Mac 程式自動排版：option + shift + f 更改相同的命名：com + d 選取多欄：shift + 點擊 跳行(游標在字裡行間也可行)：com + enter 套件：點擊html及可得知對應的css內容：按住com ＋ 點擊","text":"以下快捷鍵限支援Mac 程式自動排版：option + shift + f 更改相同的命名：com + d 選取多欄：shift + 點擊 跳行(游標在字裡行間也可行)：com + enter 套件：點擊html及可得知對應的css內容：按住com ＋ 點擊","categories":[],"tags":[{"name":"VsCode","slug":"VsCode","permalink":"https://vince-chen-hao.github.io/tags/VsCode/"}]},{"title":"CSS_圖片取代文字(SEO優化)","slug":"1204","date":"2019-12-03T16:00:00.000Z","updated":"2020-05-18T06:48:02.477Z","comments":true,"path":"2019/12/04/1204/","link":"","permalink":"https://vince-chen-hao.github.io/2019/12/04/1204/","excerpt":"SEO搜尋優化文字在SEO中的影響力仍然大於圖片，但我們也不可忽視圖片搜尋的趨勢。要兼顧排版及SEO，建議以圖文並茂、相輔相成的方式進行，若是因為版面限制，則可以運用其他可以放文字的區塊、頁面，將圖片中的內容轉換成文字，讓搜尋引擎爬蟲知道你的網站中也有這些內容！","text":"SEO搜尋優化文字在SEO中的影響力仍然大於圖片，但我們也不可忽視圖片搜尋的趨勢。要兼顧排版及SEO，建議以圖文並茂、相輔相成的方式進行，若是因為版面限制，則可以運用其他可以放文字的區塊、頁面，將圖片中的內容轉換成文字，讓搜尋引擎爬蟲知道你的網站中也有這些內容！ 瀏覽器爬蟲網頁的過程會以搜尋文字為主，採用此形式協助網站做SEO優化 目的：標題內新增圖片，讓logo背景蓋住文字內容 123456789.logo h2&#123; background-image: url(/photo/logoword.jpg); width: 200px; height: 300px; display:block; overflow: hidden; text-indent:101%; white-space:nowrap; &#125; text-indent: 101% 這是表示 段落首字縮排，將文字推出logo背景 overflow: hidden;超出 div 父元素時，自動隱藏該元素 white-space: nowrap：規定段落中的文字不得進行換行，常用於避免字數過多時自動換行導致閱讀效果變差","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://vince-chen-hao.github.io/tags/CSS/"}]},{"title":"JavaScript_基礎語法：switch判斷式","slug":"1204-2","date":"2019-12-03T16:00:00.000Z","updated":"2020-05-18T06:47:59.005Z","comments":true,"path":"2019/12/04/1204-2/","link":"","permalink":"https://vince-chen-hao.github.io/2019/12/04/1204-2/","excerpt":"switch與if的差異if else 會把每個條件跟程式碼都檢視過一次，而 switch 只會去檢視 case 內的條件是否吻合，吻合才去執行程式碼區塊，相對來說，if else 會比較消耗效能，因if語法瀏覽器會都進行處理，而switch需對應後才處理，並且跑到指定需求後便停止。除了比if語法有較快的效率，使程式碼更好閱讀，同時效能較佳，","text":"switch與if的差異if else 會把每個條件跟程式碼都檢視過一次，而 switch 只會去檢視 case 內的條件是否吻合，吻合才去執行程式碼區塊，相對來說，if else 會比較消耗效能，因if語法瀏覽器會都進行處理，而switch需對應後才處理，並且跑到指定需求後便停止。除了比if語法有較快的效率，使程式碼更好閱讀，同時效能較佳， 使用時機如有確定特定狀態便推薦使用switch，ex：只有紅燈、黃燈、綠燈三種 1234567891011121314151617var light = yellow;switch(light)&#123; // 如果是紅色就執行這區塊的程式碼 case 'red': console.log('現在是'+light); break; // 如果是黃色就執行這區塊的程式碼 case 'yellow': console.log('現在是'+light); break; // 如果上述都沒有符合的條件，就執行這區塊的程式碼 default: console.log('現在是綠燈'); break;&#125;&#125; switch嚴謹模式12345678910111213var n = '5';switch(n)&#123; case 5: console.log('success'); break; default: console.log('fail'); break;&#125;// console 輸出 fail&#125; 看起來同樣的判斷卻在 switch 和 if else 上有著不一樣的結果，這是因為 switch 在判斷上採取嚴謹模式，亦即 ===(即型別也要相同)，而在 if else 的判斷上並沒有採取這麼嚴謹的模式，需更改case’5’才能正確運行 12345678910111213switch(n)&#123; case '5': console.log('success'); break; default: console.log('fail'); break;&#125;// console 輸出 success&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/tags/JavaScript/"}]},{"title":"Slick_迅速搭建的輪播套件","slug":"1202","date":"2019-12-01T16:00:00.000Z","updated":"2020-05-18T06:47:50.553Z","comments":true,"path":"2019/12/02/1202/","link":"","permalink":"https://vince-chen-hao.github.io/2019/12/02/1202/","excerpt":"介紹Slick官網提供多種輪播樣式，可進行滑動、設定輪播等功能，我們只需要選定輪播形式後，引用js、css套件，即可使用它所支援的slider樣式。 操作步驟搜尋並引入slick cdn，加入css及js相對應程式碼 將slick.css複製到中 12&lt;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.9.0/slick.css\" /&gt;&lt;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.9.0/slick-theme.css\" /&gt; slick.js複製到段底部 12&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.9.0/slick.js\"&gt;&lt;/script&gt; 在html建立輪播的內容結構，並在外層使用一個class作標記 1234567&lt;div class=\"slider\"&gt; &lt;div&gt;slide 1&lt;/div&gt; &lt;div&gt;slide 2&lt;/div&gt; &lt;div&gt;slide 3&lt;/div&gt;&lt;/div&gt; 在slick官網上選擇sliders樣式，複製對應語法到body、script中 經由optional控制元素來調整輪播、滑動等功能設定 12345678910111213arrows: (boolean值)是否顯示左右箭頭功能dots:(boolean值)是否顯示下方小圓點功能autoplay：(boolean值)是否自動播放autoplaySpeed:(毫秒值)自動播放的速度slidesToShow:(數量值)一次主要顯現幾個slidesslidesToScroll:(數量值)每次滑動幾張slidesfade:(boolean值)是否採用淡出/淡入效果infinite：(boolean值)滑到最後一張，是否繼續從回到一開始同向循環(4&gt;1&gt;2&gt;3&gt;…)，或是逆轉向循環(4&gt;3&gt;2&gt;…)centerMode:(boolean值)是否同時顯現前後兩張slide的部分內容centerPadding:(px值)搭配centerMode:true使用，表示前後兩張slide要顯現多少範圍responsive:(陣列)針對不同尺寸做額外設定breakpoint:(螢幕尺寸)settings:(&#123;物件&#125;)包含各種設定 實作Slick幻燈片: 運動頻道","text":"介紹Slick官網提供多種輪播樣式，可進行滑動、設定輪播等功能，我們只需要選定輪播形式後，引用js、css套件，即可使用它所支援的slider樣式。 操作步驟搜尋並引入slick cdn，加入css及js相對應程式碼 將slick.css複製到中 12&lt;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.9.0/slick.css\" /&gt;&lt;link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.9.0/slick-theme.css\" /&gt; slick.js複製到段底部 12&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.9.0/slick.js\"&gt;&lt;/script&gt; 在html建立輪播的內容結構，並在外層使用一個class作標記 1234567&lt;div class=\"slider\"&gt; &lt;div&gt;slide 1&lt;/div&gt; &lt;div&gt;slide 2&lt;/div&gt; &lt;div&gt;slide 3&lt;/div&gt;&lt;/div&gt; 在slick官網上選擇sliders樣式，複製對應語法到body、script中 經由optional控制元素來調整輪播、滑動等功能設定 12345678910111213arrows: (boolean值)是否顯示左右箭頭功能dots:(boolean值)是否顯示下方小圓點功能autoplay：(boolean值)是否自動播放autoplaySpeed:(毫秒值)自動播放的速度slidesToShow:(數量值)一次主要顯現幾個slidesslidesToScroll:(數量值)每次滑動幾張slidesfade:(boolean值)是否採用淡出/淡入效果infinite：(boolean值)滑到最後一張，是否繼續從回到一開始同向循環(4&gt;1&gt;2&gt;3&gt;…)，或是逆轉向循環(4&gt;3&gt;2&gt;…)centerMode:(boolean值)是否同時顯現前後兩張slide的部分內容centerPadding:(px值)搭配centerMode:true使用，表示前後兩張slide要顯現多少範圍responsive:(陣列)針對不同尺寸做額外設定breakpoint:(螢幕尺寸)settings:(&#123;物件&#125;)包含各種設定 實作Slick幻燈片: 運動頻道","categories":[],"tags":[{"name":"Slick","slug":"Slick","permalink":"https://vince-chen-hao.github.io/tags/Slick/"}]},{"title":"JavaScript_基礎語法：呼叫函式實作","slug":"1127","date":"2019-11-26T16:00:00.000Z","updated":"2020-05-18T06:47:41.205Z","comments":true,"path":"2019/11/27/1127/","link":"","permalink":"https://vince-chen-hao.github.io/2019/11/27/1127/","excerpt":"創建一個物件：","text":"創建一個物件： 1234567 var farm = &#123; duck: 5 chicken: 10, dogs: ['柴犬','柯基'], cornField: [5,6,7]&#125; 此時若要新增一個屬性用來計算總共有多少隻家禽，如下： 1234567891011var farm = &#123; duck: 5, chicken: 10, dogs: ['柴犬','柯基'], cornField: [5,6,7], poultry: function()&#123; var total = this.duck + this.chicken; console.log(total); &#125;,&#125; 我們新增了一個 poultry 屬性，並給予一個計算小鴨跟小雞數量的函式(這裡函式可以不用命名)，當然除了上述的第一個方法，我們也可以中途加入 poultry 這個屬性，如下 12345farm.poultry = function ()&#123; var total = this.duck + this.chicken; console.log(total);&#125; 而當我們在呼叫屬性且有函式時，會比較不一樣 12farm.poultry(); 有屬性若為函式，需要跟前面講到函式時一樣，跟函式的呼叫一樣需要加括號","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/tags/JavaScript/"}]},{"title":"JavaScript_基礎語法：===等號間的嚴謹模式","slug":"1127_2","date":"2019-11-26T16:00:00.000Z","updated":"2020-05-18T06:40:48.599Z","comments":true,"path":"2019/11/27/1127_2/","link":"","permalink":"https://vince-chen-hao.github.io/2019/11/27/1127_2/","excerpt":"有一個較為嚴謹的比較模式，當等號使用==時，左右兩邊並不會比較資料型別，而會自動去轉型做比較，專業回答：兩個等於（==）會對被判別的變數做轉換型別的動作（coercion又稱為implicit type conversion）","text":"有一個較為嚴謹的比較模式，當等號使用==時，左右兩邊並不會比較資料型別，而會自動去轉型做比較，專業回答：兩個等於（==）會對被判別的變數做轉換型別的動作（coercion又稱為implicit type conversion） 例如：1 == ‘1’，數字1等於字串1，這時候會回傳 true，JavaScript 會自動把字串1先轉型成數字1，再去做比較 如果在===的情況下，1 === ‘1’ ，數字1並不會等於字串1，會回傳 false 因為數字跟字串本身就是不一樣的資料型別，所以在比較的時候會先從資料型別去做比較，如果兩邊的資料型別不一樣，則就先回傳 false ，所以這是較嚴謹的比較模式。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/tags/JavaScript/"}]},{"title":"JavaScript_語法解析、執行/詞彙環境","slug":"1123_1","date":"2019-11-22T16:00:00.000Z","updated":"2020-05-18T06:40:13.852Z","comments":true,"path":"2019/11/23/1123_1/","link":"","permalink":"https://vince-chen-hao.github.io/2019/11/23/1123_1/","excerpt":"語法解析器(syntax parser)包含直譯器、編譯器，會一個字一個字讀取並辨識程式碼是否有效，再將之轉換成為電腦可以解讀的指令","text":"語法解析器(syntax parser)包含直譯器、編譯器，會一個字一個字讀取並辨識程式碼是否有效，再將之轉換成為電腦可以解讀的指令 詞彙環境(lexical environment)程式碼在程式中實際的所在位置，對於某些程式語言非常重要，例：JavaScript。 因為當systax parser在解讀並轉換程式碼時， 會考量該變數、函式的lexical environment，而影響到它實際在記憶體中的位置或是跟其他變數、函式作用的關係。 123function hello()&#123; var a = 'Hello';&#125; 變數a的lexical environment就是hello()這個函式。 執行環境(execution context)一個程式碼中有多個lexical environment，因此execution context負責協助管理正在執行的程式，如同一個wrapper，包含我們撰寫的程式碼，以及syntax parser執行轉換的程式碼。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/tags/JavaScript/"}]},{"title":"JavaScript_基礎語法：呼叫函式實作","slug":"1123_3","date":"2019-11-22T16:00:00.000Z","updated":"2020-05-18T06:40:43.106Z","comments":true,"path":"2019/11/23/1123_3/","link":"","permalink":"https://vince-chen-hao.github.io/2019/11/23/1123_3/","excerpt":"創建一個物件如程式碼：","text":"創建一個物件如程式碼： 1234567 var farm = &#123; duck: 5 chicken: 10, dogs: ['柴犬','柯基'], cornField: [5,6,7]&#125; 此時若要新增一個屬性用來計算總共有多少隻家禽，如下： 1234567891011var farm = &#123; duck: 5, chicken: 10, dogs: ['柴犬','柯基'], cornField: [5,6,7], poultry: function()&#123; var total = this.duck + this.chicken; console.log(total); &#125;,&#125; 我們新增了一個 poultry 屬性，並給予一個計算小鴨跟小雞數量的函式(這裡函式可以不用命名)，當然除了上述的第一個方法，我們也可以中途加入 poultry 這個屬性，如下 12345farm.poultry = function ()&#123; var total = this.duck + this.chicken; console.log(total);&#125; 而當我們在呼叫屬性且有函式時，會比較不一樣 12farm.poultry(); 有屬性若為函式，需要跟前面講到函式時一樣，跟函式的呼叫一樣需要加括號","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/tags/JavaScript/"}]},{"title":"JavaScript_基礎語法：渲染id/屬性","slug":"1123_2","date":"2019-11-22T16:00:00.000Z","updated":"2020-05-18T06:40:18.205Z","comments":true,"path":"2019/11/23/1123_2/","link":"","permalink":"https://vince-chen-hao.github.io/2019/11/23/1123_2/","excerpt":"代入id渲染方式在 JavaScript 裡，當想要選取一個 id 渲染到網頁上時，可以使用下面的語法：","text":"代入id渲染方式在 JavaScript 裡，當想要選取一個 id 渲染到網頁上時，可以使用下面的語法： 1document.getElementById(''); 假使今天想要選取一個 id 且為hello，則可以這樣寫： 12document.getElementById('hello'); 接下來介紹一個新增文字的方式，再選取完一個 id 且為hello時，想渲染一些文字時，可以如下：document.getElementById(‘hello’).textContent = ‘這是一段文字’; 實作12345&lt;p id=\"test\"&gt;文字1&lt;/p&gt;&lt;script&gt; document.getElementById('test').textContent=\"修改後標題\";&lt;/script&gt; 12&lt;p id=\"test\"&gt;修改後標題&lt;/p&gt;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/tags/JavaScript/"}]},{"title":"JavaScript_宣告事件的三種方式","slug":"1120","date":"2019-11-19T16:00:00.000Z","updated":"2020-05-18T06:40:09.968Z","comments":true,"path":"2019/11/20/1120/","link":"","permalink":"https://vince-chen-hao.github.io/2019/11/20/1120/","excerpt":"一般在撰寫事件有三種方式，第一種也是較為早期的一種，也是不推薦使用的方式，因為較容易受到外來的攻擊，關鍵是在 onclick=“hello();” 在這裡面可以撰寫 JS，所以也較容易受到外來的方式改寫程式碼，也是較為危險的方式","text":"一般在撰寫事件有三種方式，第一種也是較為早期的一種，也是不推薦使用的方式，因為較容易受到外來的攻擊，關鍵是在 onclick=“hello();” 在這裡面可以撰寫 JS，所以也較容易受到外來的方式改寫程式碼，也是較為危險的方式 第一種1&lt;input type=\"button\" class=\"btn\" value=\"點擊\" onclick=\"hello();\"&gt; 第二種直接把事件內容全寫在 JS 檔內，而不是 HTML 內 12345var el = document.querySelector('.btn');el.onclick = function()&#123; alert('Hello');&#125; 第三種採用addEventListener() 方法，俗稱事件監聽，來做事件的綁定 12345var el = document.querySelector('.btn');el.addEventListener('click',function()&#123; alert('Hello');&#125;) 比較彼此差異撇除掉第一種較危險的方式之外，來談談第二種跟第三種的差異性這兩個方法差異性在哪裡？假設我們今天同一個元素要綁定多個事件時：當採用第一種方法 12345678910&lt;script&gt; var el = document.querySelector('.btn'); el.onclick = function()&#123; alert('Hello1'); &#125; el.onclick = function()&#123; alert('Hello2'); &#125;&lt;/script&gt; 這時候只會彈跳 Hello2 出來，第一個 click 事件被蓋掉了，而使用另外一種方法時 123456789101112&lt;script&gt; var el = document.querySelector('.btn'); el.addEventListener('click',function()&#123; alert('Hello1'); &#125; &#125;) el.addEventListener('click',function()&#123; alert('Hello2'); &#125; &#125;) &lt;/script&gt; 這時候會發現，會依序彈跳 Hello1 Hello2，事件會依序出來，並不會被蓋掉上述就是其差異性，為了避免這種狀況，建議之後可以改用 .addEventListener()的方式","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/tags/JavaScript/"}]},{"title":"JavaScript_解析BOM與DOM","slug":"1120_2","date":"2019-11-19T16:00:00.000Z","updated":"2020-05-18T06:40:06.137Z","comments":true,"path":"2019/11/20/1120_2/","link":"","permalink":"https://vince-chen-hao.github.io/2019/11/20/1120_2/","excerpt":"什麼是BOM？瀏覽器物件模型（Browser Object Model,BOM）是瀏覽器提供的附加對象，用於處理 document 以外的所有内容，主要處理瀏覽器窗口和框架，不过通常瀏覽器特定的 JavaScript 也會被看作 BOM 的一部分。區別：BOM 描述了與瀏覽器進行交互的方法和接口，DOM 描述了處理網頁内容的方法和接口。","text":"什麼是BOM？瀏覽器物件模型（Browser Object Model,BOM）是瀏覽器提供的附加對象，用於處理 document 以外的所有内容，主要處理瀏覽器窗口和框架，不过通常瀏覽器特定的 JavaScript 也會被看作 BOM 的一部分。區別：BOM 描述了與瀏覽器進行交互的方法和接口，DOM 描述了處理網頁内容的方法和接口。 window 物件包含属性：document、navigator、frames、history、location、screen document 根節點包含子節點：forms、location、anchors、images、links 什麼是DOM(Document Object Model)？檔案物件模型（Document Object Model, DOM）是瀏覽器的執行規範，提供了結構化的標準方法，將網頁的程式碼及其他程式語言結合起來。開發人員即可以通過文件中物件的屬性、方法和事件來掌控、操縱和建立動態的網頁元素。 每個 DOM 的基礎建置在一個(D)文件上（也就是以 document 作為根基），而由 document 中的每個(O)物件作為出一個個節點，最後由這一個個節點，組成為一個 DOM Tree。 D：（文件）瀏覽器當前載入的 document O：（物件）將 document 中的所有元素視為物件，可以調用其屬性、方法 M：（模型）所有的物件在該結構中都是節點，這些眾多節點組成一個樹狀結構 DOM 節點有: 元素節點：上圖中html、body、p標籤皆是元素節點。 文本節點:向用户展示的内容，如li…/li中的 JavaScript、DOM、CSS 等文本。 屬性節點:標籤中的屬性，如a標籤中的連結屬性href=”http://www.yahoo.com&quot;。 DOM 操作用 DOM API 可以輕鬆地删除、添加和替換節點。| DOM 操作 |说明 || ————- |:————-:||creatElement(element) |創建一个新的元素節點||creatTextNode() |創建一个包含給定文本的新文本節點||appendChild() |指定節點的最後一個節點列表後添加一个新的子節點||insertBefore() |將一個給定節點节点插入到一个給定元素節點的給定子節點的前面||removeChild() |从一个给定元素中删除子节点||replaceChild() |把一个给定父元素里的一个子节点替换为另外一个节点|","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/tags/JavaScript/"}]},{"title":"Bootstrap_navbar導覽頁面","slug":"1115","date":"2019-11-14T16:00:00.000Z","updated":"2020-05-18T06:40:01.295Z","comments":true,"path":"2019/11/15/1115/","link":"","permalink":"https://vince-chen-hao.github.io/2019/11/15/1115/","excerpt":"navbar導覽使用方式 nav外層使用包住時，Navbar導覽列放置在頁面中央或內容的中間，若沒有設定container，導覽列預設的內容寬度是浮動，並自動佔滿水平寬度 透過navbar-expand定義在何種尺寸，menu項目的呈現會改為「漢堡折疊」樣式效果 使用bootstrap自定義的data-toggle及data-target，決定按鈕點下之後，menu的div要以collapse方式展開 navbar-expand-sm大小則是決定當螢幕尺寸小於sm時，會改為以「三」顯示menu項目","text":"navbar導覽使用方式 nav外層使用包住時，Navbar導覽列放置在頁面中央或內容的中間，若沒有設定container，導覽列預設的內容寬度是浮動，並自動佔滿水平寬度 透過navbar-expand定義在何種尺寸，menu項目的呈現會改為「漢堡折疊」樣式效果 使用bootstrap自定義的data-toggle及data-target，決定按鈕點下之後，menu的div要以collapse方式展開 navbar-expand-sm大小則是決定當螢幕尺寸小於sm時，會改為以「三」顯示menu項目 123456789101112131415161718192021222324252627&lt;nav id=\"main-nav\" class=\"navbar navbar-expand-sm navbar-dark fixed-top\" &gt;&lt;nav class=\"nav navbar-default\"&gt; &lt;div class=\"container-fluid\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\"#Navbarshow\"&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=\"navbar-brand\" href=\"#\"&gt;Brand&lt;/a&gt; &lt;/div&gt; &lt;div class=\"collapse navbar-collapse\" id=\"Navbarshow\"&gt; //底下放要縮放的內容 &lt;ul class=\"nav navbar-nav\"&gt; &lt;li&gt;&lt;a data-toggle=\"tab\" href=\"#home\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a data-toggle=\"tab\" href=\"#menu1\"&gt;Page 1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a data-toggle=\"tab\" href=\"#menu2\"&gt;Page 2&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"nav navbar-nav navbar-right\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;span class=\"glyphicon glyphicon-log-in\"&gt;&lt;/span&gt; Log in&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Log out&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;span class=\"glyphicon glyphicon-user\"&gt;&lt;/span&gt; Admin&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt; 建立漢堡按鍵步驟 class=”navbar-toggle”：這個是關鍵字，有它才能讓我們順利看到漢堡按鍵，並出現在視窗右方。 data-toggle=”collapse”：這是用來製作動畫效果的，沒有的話，我們點「三」的時候不會有任何反應。 data-target=”#myNavbar”這裡面的myNavbar是一個CSS的id，可以任意命名，一定要跟下面縮放的id對應才可執行。 這段這是用來產生「一」，當有三個「一」時，合在一起就會變「三」的按鍵了。 class=”collapse navbar-collapse”：這兩字詞幫助我們在正常視窗的情況下，可以看到原本的導覽列。 id=”Navbarshow”與button裡的data-target做對應，能讓我們看到縮放裡的內容 如果希望navbar不會受頁面捲動下移而消失，則在class加上fixed-top，變會置頂在最上方","categories":[],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://vince-chen-hao.github.io/tags/Bootstrap/"}]},{"title":"Bootstrap_Collapse & Accordion折疊語法","slug":"1114","date":"2019-11-13T16:00:00.000Z","updated":"2020-05-18T06:39:53.116Z","comments":true,"path":"2019/11/14/1114/","link":"","permalink":"https://vince-chen-hao.github.io/2019/11/14/1114/","excerpt":"什麼是Collapse折疊？使特定的頁面區塊隱藏起來，當點擊某些按鈕或者動作時，資料才會顯現出來。","text":"什麼是Collapse折疊？使特定的頁面區塊隱藏起來，當點擊某些按鈕或者動作時，資料才會顯現出來。 12345&lt;button data-toggle=\"collapse\" data-target=\"#demo\"&gt;Collapsible&lt;/button&gt;&lt;div id=\"demo\" class=\"collapse\"&gt;Lorem ipsum dolor text....&lt;/div&gt; 按鈕上一定要有 data-toggle=“collapse” 這個宣告詞，然後需要顯示的資訊在 data-target=”#demo” 的連結上。 再利用 div 或者是其他區塊類的元素，增加 id=“demo”，重要的是 demo 跟 button 的 data-target 命名必須相同才可運作。 預設的折疊效果是隱藏的，點擊才會出現，若要設定為展開開狀態，在collapse後方添加show便可顯現。 Accordion隱藏折疊資料透過 Accordion 的方法來處理時，看起來所有的連結會比較整齊， FAQ 問答頁面多使用這種模式。 123456789101112131415161718&lt;div id=\"accordion\" &gt; &lt;div class=\"card\"&gt; &lt;div class=\"card-header\"&gt; &lt;h5 class=\"mb-0\"&gt; &lt;div href=\"#collapse1\" data-toggle=\"collapse\" data-parent=\"#accordion\"&gt; &lt;i class=\"fas fa-chevron-circle-down\"&gt;&lt;/i&gt; Good Deal&lt;/div&gt; &lt;/h5&gt; &lt;/div&gt; &lt;div id=\"collapse1\" class=\"collapse show\"&gt; &lt;div class=\"card-body\"&gt; Lorem ipsum dolor, sit amet consectetur adipisicing elit... &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 實作成果","categories":[],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://vince-chen-hao.github.io/tags/Bootstrap/"}]},{"title":"Bootstrap_宣告指令（移動區塊、改變色系）","slug":"1113","date":"2019-11-12T16:00:00.000Z","updated":"2020-05-18T06:39:40.585Z","comments":true,"path":"2019/11/13/1113/","link":"","permalink":"https://vince-chen-hao.github.io/2019/11/13/1113/","excerpt":"色系調色盤-bg/text","text":"色系調色盤-bg/text 1&lt;p class=\"text-primary\"&gt;調整文字色系&lt;/p&gt; 移動位置區塊-p/m 移動y軸代表調整上下位置，x軸則是左右位置 pl= padding left| py= padding top &amp; bottom ml= margin left 響應式圖片 img-fluid自動縮放圖片寬度 rounded 可以讓圖片顯示圓角傚果 rounded-circle 可以設置橢圓形圖片 1&lt;img src=\"...\" class=\"img-fluid rounded\" alt=\"Responsive image\"&gt; 背景圖background-attachment是背景固定模式的屬性，而不同的固定模式就有不一樣的視覺效果 scroll模式也是預設值，背景圖會隨著外圍頁面滾動而移動。 fixed模式，不管外面、裡面怎麼滾，他都是不會動的。 local模式，主要的特色就是，自己的區塊內如果滾動時，背景圖也會跟著移動。 icon圖型i標籤將想使用的icon圖寫入欲出現位置 1&lt;i class=\"fas fa-band-aid\"&gt;&lt;/i&gt; More info: font-awesome","categories":[],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://vince-chen-hao.github.io/tags/Bootstrap/"}]},{"title":"Bootstrap_GridSystem 配置版面","slug":"1111","date":"2019-11-10T16:00:00.000Z","updated":"2020-05-18T06:39:26.173Z","comments":true,"path":"2019/11/11/1111/","link":"","permalink":"https://vince-chen-hao.github.io/2019/11/11/1111/","excerpt":"定義網格規則 Bootstrap使用flexbox建立網格系統，符合響應式設計，並且能夠更方便的實現等高及對齊置中效果。","text":"定義網格規則 Bootstrap使用flexbox建立網格系統，符合響應式設計，並且能夠更方便的實現等高及對齊置中效果。 定義列與行的語法，先決定外層row列數，再設定內層的寬度col，寬度bootstrap定義分成12等分， &lt;div class=&quot;col-[裝置尺寸]-[寬度大小]&quot;&gt; 定義螢幕尺寸(xs, sm, md, lg) 範例：&lt;div class=”col-md-6&gt; 在md的大小時會佔據6/12一半的寬度(深綠色)，程式碼如下: 1234567&lt;div class=\"row\"&gt; &lt;div class=\"col-md-12 text-center\"&gt;12/12&lt;/div&gt;&lt;/div&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-md-6 text-center\"&gt;6/12&lt;/div&gt; &lt;div class=\"col-md-6 text-center\"&gt;6/12&lt;/div&gt;&lt;/div&gt; 垂直對齊容器位置可以在.row的 class 加上：左-&gt;align-items-start右-&gt;align-items-end中-&gt;align-items-center 水平調整容器位置 補充資料 在預設的情況下，每一個欄（column）之間都會有間隙（gutter），透過在 .row 上加上 .no-gutters 即可去除 我們可以在同一個 column 上給多的 class 來讓頁面在不同螢幕尺寸時有不同的排版：&lt;div class=&quot;col-sm-4 col-md-8&quot;&gt;&lt;/div&gt;當螢幕尺寸為md以上時會以8/12顯示，sm則以4/12顯示","categories":[],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://vince-chen-hao.github.io/tags/Bootstrap/"}]},{"title":"Bootstrap_Carousel輪播幻燈片","slug":"1111_2","date":"2019-11-10T16:00:00.000Z","updated":"2020-05-18T06:39:18.561Z","comments":true,"path":"2019/11/11/1111_2/","link":"","permalink":"https://vince-chen-hao.github.io/2019/11/11/1111_2/","excerpt":"Carousel中文為幻燈片的意思，在元件裡面可以添加控制元素來控制幻燈片的播放。","text":"Carousel中文為幻燈片的意思，在元件裡面可以添加控制元素來控制幻燈片的播放。 組成結構分為三個元素組成 Carousel item Carousel controls Carousel indicators Carousel item項目12345678910111213&lt;div id=\"myCarousel\" class=\"carousel slide\" data-ride=\"carousel\"&gt; &lt;div class=\"carousel-inner\"&gt; &lt;div class=\"carousel-item active\"&gt; &lt;img class=\"d-block w-100\" src=\"img/bg1.jpg\" alt=\"slide01\"&gt; &lt;/div&gt; &lt;div class=\"carousel-item\"&gt; &lt;img class=\"d-block w-100\" src=\"img/bg2.jpg\" alt=\"slide01\"&gt; &lt;/div&gt; &lt;div class=\"carousel-item\"&gt; &lt;img class=\"d-block w-100\" src=\"img/bg3.jpg\" alt=\"slide01\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 添加一個carousel容器，他可以包裝整個幻燈片組建所需的元件 內容放在一個carousel-inner 容器裡並在項目中carousel-item放置圖片與資訊內容 d-block代表display:block為佔據一行，w-100表示寬度100 data-ride 讓幻燈片可以自動切換 預設頻率是每五秒更換一次，若需要有滑動效果可以在最外面加個 slide。 Controls控制項123456&lt;a href=\"#myCarousel\" data-slide=\"prev\" class=\"carousel-control-prev\"&gt; &lt;span class=\"carousel-control-prev-icon\"&gt; &lt;/span&gt;&lt;/a&gt;&lt;a href=\"#myCarousel\" data-slide=\"next\" class=\"carousel-control-next\"&gt; &lt;span class=\"carousel-control-next-icon\"&gt;&lt;/span&gt;&lt;/a&gt; 在data-slide分別設置prv及next以完成設定左右切換圖片的功能 indicators指示器12345&lt;ol class=\"carousel-indicators\"&gt; &lt;li data-target=\"#myCarousel\" data-slide-to=\"0\" class=\"active\"&gt;&lt;/li&gt; &lt;li data-target=\"#myCarousel\" data-slide-to=\"1\"&gt;&lt;/li&gt; &lt;li data-target=\"#myCarousel\" data-slide-to=\"2\"&gt;&lt;/li&gt;&lt;/ol&gt; 使用ol及li列表結構並套用carousel-indicators 每個li標籤對應一個slide，並將active加入到齊幻燈片內，否則輪播將看不見。 改變slide停留時間每張幻燈片預設的停留時間為5秒，如果想要改變停留的時間，可加上interval這個選項，調整滯留的秒數。 1234$('.carousel').carousel(&#123; interval: 6000, pause: 'hover' &#125;); 取消自動輪播將interval設為false即可取消自動輪播 123$('.carousel').carousel(&#123; interval: false&#125;) 鼠標滑入持續輪播Carousel預設是當鼠標滑入時，輪播就會暫停。若想要讓滑鼠滑入時繼續輪播，就可使用以下設定。 1234$('.carousel').carousel(&#123; pause: false&#125;) 停止循環播放bootstrap預設data-wrap：ture（循環播放），若投影片只想播放一個循環，更改為false即可停止無限循環。 12&lt;div id=\"myCarousel\" class=\"carousel slide\" data-wrap=\"false\" data-ride=\"carousel\"&gt; 實作成果首頁輪播: 運動頻道","categories":[],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://vince-chen-hao.github.io/tags/Bootstrap/"}]},{"title":"HTML_解析絕對/相對路徑","slug":"1110","date":"2019-11-09T16:00:00.000Z","updated":"2020-05-18T06:39:09.749Z","comments":true,"path":"2019/11/10/1110/","link":"","permalink":"https://vince-chen-hao.github.io/2019/11/10/1110/","excerpt":"定義「相對路徑」和「絕對路徑」 相對路徑是相對於現在目錄的路徑表示，也就是你現在這個檔案在哪裡，這個目錄的路徑起始點就在哪裡，所以每個檔案的相對路徑起始點都可能會不同 絕對路徑是一個絕對位置，他不會隨著檔案位置的變換而改變他的路徑。","text":"定義「相對路徑」和「絕對路徑」 相對路徑是相對於現在目錄的路徑表示，也就是你現在這個檔案在哪裡，這個目錄的路徑起始點就在哪裡，所以每個檔案的相對路徑起始點都可能會不同 絕對路徑是一個絕對位置，他不會隨著檔案位置的變換而改變他的路徑。 舉例的路徑符號 「.」是代表目前所在目錄 「..」是代表上層目錄，若目前已經是根目錄則依然為目前所在目錄 「/」在各個目錄名稱之間的分隔符號，若放置在路徑之前則代表根目錄 相對路徑顯示圖片 絕對路徑顯示圖片","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://vince-chen-hao.github.io/tags/HTML/"}]},{"title":"CSS_reset重置樣式","slug":"1103","date":"2019-11-02T16:00:00.000Z","updated":"2020-05-18T06:39:01.681Z","comments":true,"path":"2019/11/03/1103/","link":"","permalink":"https://vince-chen-hao.github.io/2019/11/03/1103/","excerpt":"使用時機通常在做網頁切版時，都會有瀏覽器自帶的 CSS 樣式檔案，用以呈現各個瀏覽器特有的預設外觀。雖然有預設樣式的好處是，當開發者沒有特別定義樣式時，至少會有基礎的排版、樣式效果；可是壞處是，當開發者自定義樣式時，經常會因此而出現不可預期的狀況。所以在做切版時，都會用 CSS Reset，將瀏覽器預設的樣式通通歸零，包含行距離、字距、margin、padding⋯ 等。","text":"使用時機通常在做網頁切版時，都會有瀏覽器自帶的 CSS 樣式檔案，用以呈現各個瀏覽器特有的預設外觀。雖然有預設樣式的好處是，當開發者沒有特別定義樣式時，至少會有基礎的排版、樣式效果；可是壞處是，當開發者自定義樣式時，經常會因此而出現不可預期的狀況。所以在做切版時，都會用 CSS Reset，將瀏覽器預設的樣式通通歸零，包含行距離、字距、margin、padding⋯ 等。 最普遍常用的 CSS-Reset 為 Eric Meyer 版本將 Eric Meyer 版本 寫好的程式碼內容，全部複製一份到個人專案中的一個 CSS 檔案中，可以命名為 reset.css 接著在專案中的每個 html 都引入 reset.css ，這樣就可以確定每個頁面在一開始的樣式都被歸零。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/* http://meyerweb.com/eric/tools/css/reset/ v2.0 | 20110126 License: none (public domain)*/html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video &#123; margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline;&#125;/* HTML5 display-role reset for older browsers */article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section &#123; display: block;&#125;body &#123; line-height: 1;&#125;ol,ul &#123; list-style: none;&#125;blockquote,q &#123; quotes: none;&#125;blockquote:before,blockquote:after,q:before,q:after &#123; content: ''; content: none;&#125;table &#123; border-collapse: collapse; border-spacing: 0;&#125; 內容即為將很多樣式都歸零，如此一來，不論使用者的瀏覽器版本，在 CSS Reset 之後，都是統一無樣式的版本。而開發過程中，也不會因為 各個瀏覽器各自的預設值，而影響到開發者重新自定義的樣式，進而發生不可預知的狀況。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://vince-chen-hao.github.io/tags/CSS/"}]},{"title":"CSS_轉場特效(transitions)","slug":"1102","date":"2019-11-01T16:00:00.000Z","updated":"2020-05-18T06:38:53.087Z","comments":true,"path":"2019/11/02/1102/","link":"","permalink":"https://vince-chen-hao.github.io/2019/11/02/1102/","excerpt":"使用時機想在滑鼠移上去的時候做一點效果，希望能讓整個頁面看起來更精緻，為了使畫面在轉場時變得生動，此時就很適合用到有漸變的動畫的transition。例：hover設定浮出來的效果（box shadow）並且變亮。注意：transition需寫在外層裡(尚未觸發前)，而非在hover效果層內。","text":"使用時機想在滑鼠移上去的時候做一點效果，希望能讓整個頁面看起來更精緻，為了使畫面在轉場時變得生動，此時就很適合用到有漸變的動畫的transition。例：hover設定浮出來的效果（box shadow）並且變亮。注意：transition需寫在外層裡(尚未觸發前)，而非在hover效果層內。 123456789101112131415&lt;section id=\"video-play\"&gt; &lt;div class=\"dark-overlay\"&gt; &lt;!-- 背景暗色 --&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt; &lt;div class=\"container p-5\"&gt;&lt;!-- padding --&gt; &lt;a href=\"#\" class=\"video\" data-video=\"https://www.youtube.com/embed/SjJ08V166uU\" data-toggle=\"modal\" data-target=\"#videoModal\"&gt; &lt;i class=\"fas fa-play fa-3x\"&gt;&lt;/i&gt;&lt;!--data-toggle 通常會伴隨一個icon，告知系統在點擊後會觸發另一個行動 --&gt; &lt;/a&gt; &lt;h1&gt;Watch Our Publicity Film&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 進階效果設定 box-shadow陰影效果，也能在chrome內建工具進行細部調整 filter效果brightness是可以調整亮度 transform: scale(1.2) //指定元素由參考點縮放 m 倍 參考網站: filterCSS属性 濾鏡效果製造器","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://vince-chen-hao.github.io/tags/CSS/"}]},{"title":"CSS_區塊元素與行內元素","slug":"1028","date":"2019-10-26T16:00:00.000Z","updated":"2020-05-18T06:38:36.856Z","comments":true,"path":"2019/10/27/1028/","link":"","permalink":"https://vince-chen-hao.github.io/2019/10/27/1028/","excerpt":"區塊元素(block) 在新的一行開始 若沒有定義該元素長寬，則會100%佔滿所在空間 例：會佔滿整個區塊(整行) css語法：display:block;","text":"區塊元素(block) 在新的一行開始 若沒有定義該元素長寬，則會100%佔滿所在空間 例：會佔滿整個區塊(整行) css語法：display:block; 12345678區塊元素常見包括div、p、h1~h6、ul、ol、li、dl、dt、dd、form、table、hr、blockquote 、address、menu、pre.....等等 行內元素(inline) 不一定會在新的一行開始 該元素佔有的空間為其內容本身(文字或圖片)之長寬 無法重新自定義長寬 可能其他元素並排(視空間寬度而定) 例：span會接續前方元素，不會換行 123456行內元素常見包括span、em、i、b、strong、a、img、input、br、select、textarea、q、bdo、sub、sup 空元素特點1.没有内容的 HTML 元素被稱為空元素。空元素是在開始標籤中關閉的。2.由於HTML元素的内容是開始標籤与结束標籤之间的内容。 而某些HTML元素具有空内容。那些含有空内容的HTML元素，就是空元素。3.單標籤，只有開始標籤，没有结束標籤 空元素常見包括 123&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;&lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt;...等等 More info: 參考連結","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://vince-chen-hao.github.io/tags/CSS/"}]},{"title":"CSS_絕對/相對定位","slug":"1027","date":"2019-10-26T16:00:00.000Z","updated":"2020-05-18T06:38:32.360Z","comments":true,"path":"2019/10/27/1027/","link":"","permalink":"https://vince-chen-hao.github.io/2019/10/27/1027/","excerpt":"absolute 元素的定位是在他所處上層容器的相對位置 如果沒有寫relative對應，則會依照瀏覽器預設的寬高為基準 若要頁面「並排」可使用float，「重疊」可用相對定位語法","text":"absolute 元素的定位是在他所處上層容器的相對位置 如果沒有寫relative對應，則會依照瀏覽器預設的寬高為基準 若要頁面「並排」可使用float，「重疊」可用相對定位語法 單獨使用relative及absolute的解析 單設定一組absolute，會以body裡為範圍做位置上的移動，因此在設定一組absolute前，我們w通常會需要先新增一組relative當作外框架的基準，才能在目前的區塊去做移動而不是整個大body 單設定一組relative，則box會以class目前所在的位置做移動(top:20px) 設定重疊順序z-indexbox1: z-index=2box2: z-index=1結果：box1會重疊在box2區塊上方","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://vince-chen-hao.github.io/tags/CSS/"}]},{"title":"CSS_遮罩層overlay效果","slug":"1029","date":"2019-10-26T16:00:00.000Z","updated":"2020-05-18T06:38:41.611Z","comments":true,"path":"2019/10/27/1029/","link":"","permalink":"https://vince-chen-hao.github.io/2019/10/27/1029/","excerpt":"使用overlay通常是要上層壓字，使文字能更清楚呈現，下圖為遮罩效果的差異","text":"使用overlay通常是要上層壓字，使文字能更清楚呈現，下圖為遮罩效果的差異 範例圖樣 123456789101112131415&lt;section id=\"video-play\"&gt; &lt;div class=\"dark-overlay\"&gt; &lt;!-- 背景暗色 --&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt; &lt;div class=\"container p-5\"&gt;&lt;!-- padding --&gt; &lt;a href=\"#\" class=\"video\" data-video=\"https://www.youtube.com/embed/SjJ08V166uU\" data-toggle=\"modal\" data-target=\"#videoModal\"&gt; &lt;i class=\"fas fa-play fa-3x\"&gt;&lt;/i&gt;&lt;!--data-toggle 通常會伴隨一個icon，告知系統在點擊後會觸發另一個行動 --&gt; &lt;/a&gt; &lt;h1&gt;Watch Our Publicity Film&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 設定CSS條件 調整背景的opacity透明度 透過相對、絕對定位調整遮罩位置，重疊 12345678910111213141516171819#video-play &#123; position: relative; min-height: 200px; background: url('../img/Video.jpg'); background-attachment: fixed; background-repeat: no-repeat; text-align: center; color: #fff;&#125;.dark-overlay &#123; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); //透明度&#125; 實作Demo: 體育新聞網站","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://vince-chen-hao.github.io/tags/CSS/"}]},{"title":"CSS_圖解flex的容器位置","slug":"1025","date":"2019-10-24T16:00:00.000Z","updated":"2020-05-18T06:38:26.513Z","comments":true,"path":"2019/10/25/1025/","link":"","permalink":"https://vince-chen-hao.github.io/2019/10/25/1025/","excerpt":"容器之內的物件可並行接續排列，並且每個物件都有固定比例占據該容器","text":"容器之內的物件可並行接續排列，並且每個物件都有固定比例占據該容器 外層容器的display屬性為flex 在內層物件中，各自定義佔據的寬度或剩餘空間的分配比例 為了避免 ==外層容器空間不足== ，可以min-width輔助定義最小的寬度 定義排序方向為「上到下」 定義「自動換行」 調整容器位置的三種方式 justify-content 調整水平方向 align-items 調整垂直方向 align-self 調整內層的垂直方向","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://vince-chen-hao.github.io/tags/CSS/"}]},{"title":"HTML_SEO網頁優化(優化Head項目)","slug":"1021","date":"2019-10-20T16:00:00.000Z","updated":"2020-05-18T06:38:12.795Z","comments":true,"path":"2019/10/21/1021/","link":"","permalink":"https://vince-chen-hao.github.io/2019/10/21/1021/","excerpt":"把Head標籤的關鍵詞布局做好，讓這標籤中的title、keywrods、Description相輔相成，那麼你的網站，在搜尋引擎中將會有個好的開始。","text":"把Head標籤的關鍵詞布局做好，讓這標籤中的title、keywrods、Description相輔相成，那麼你的網站，在搜尋引擎中將會有個好的開始。 Head標籤優化網頁之關鍵詞(keywords)標題優化Keywords中，關鍵詞是頁面關鍵詞，雖然已經被眾多黑帽SEO利用，導致權重下降，但仍然是搜尋引擎關注點之一，Keywords應該限制在6-8個關鍵詞。 Head標籤優化網頁之描述Description優化Description中，對於關鍵詞的作用明顯降低，但由於很多的搜尋引擎，仍然大量採用網頁的META標籤中的描述部分作為搜索結果的「內容摘要」，Description不僅對我們的網站的排名有很大的作用，更加對如有銷售目的是十分重要的，好的Description不僅吸引搜索者點擊，更加會促進網站的轉化率。 Head可優化項目123456789101112131415161718&lt;link rel=\"shortcut icon\" href=\"favicon.ico\"&gt;&lt;meta name='description' content='網站描述文字' /&gt;&lt;meta name=\"application-name\" content='品牌名稱' /&gt;&lt;meta name=\"keywords\" content='網站關鍵字' /&gt;&lt;meta property=\"og:title\" content=\"FB的標題\" /&gt;&lt;meta property=\"og:description\" content=\"FB的描述\"&gt;&lt;meta property=\"og:type\" content=\"website\" /&gt;&lt;meta property=\"og:url\" content=\"FB上的網址\" /&gt;&lt;meta property=\"og:image\" content=\"FB的圖片\" /&gt;&lt;link href=\"圖片路徑\" rel=\"apple-touch-icon\" /&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\" /&gt;&lt;link rel=\"stylesheet\" href=\"CSS檔案路徑\"&gt;&lt;script type=\"text/javascript\" src=\"JS檔案路徑\"&gt;&lt;/script&gt; More info: Head進階資訊設定","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://vince-chen-hao.github.io/tags/HTML/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-12-31T16:00:00.000Z","updated":"2020-05-18T06:49:12.764Z","comments":true,"path":"2019/01/01/hello-world/","link":"","permalink":"https://vince-chen-hao.github.io/2019/01/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"前端文","slug":"前端文","permalink":"https://vince-chen-hao.github.io/tags/%E5%89%8D%E7%AB%AF%E6%96%87/"},{"name":"教學文","slug":"教學文","permalink":"https://vince-chen-hao.github.io/tags/%E6%95%99%E5%AD%B8%E6%96%87/"}]}],"categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://vince-chen-hao.github.io/tags/Vue/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://vince-chen-hao.github.io/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"https://vince-chen-hao.github.io/tags/jQuery/"},{"name":"ES6","slug":"ES6","permalink":"https://vince-chen-hao.github.io/tags/ES6/"},{"name":"Webpack","slug":"Webpack","permalink":"https://vince-chen-hao.github.io/tags/Webpack/"},{"name":"Git","slug":"Git","permalink":"https://vince-chen-hao.github.io/tags/Git/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://vince-chen-hao.github.io/tags/Bootstrap/"},{"name":"JSON","slug":"JSON","permalink":"https://vince-chen-hao.github.io/tags/JSON/"},{"name":"CSS","slug":"CSS","permalink":"https://vince-chen-hao.github.io/tags/CSS/"},{"name":"VsCode","slug":"VsCode","permalink":"https://vince-chen-hao.github.io/tags/VsCode/"},{"name":"Slick","slug":"Slick","permalink":"https://vince-chen-hao.github.io/tags/Slick/"},{"name":"HTML","slug":"HTML","permalink":"https://vince-chen-hao.github.io/tags/HTML/"},{"name":"前端文","slug":"前端文","permalink":"https://vince-chen-hao.github.io/tags/%E5%89%8D%E7%AB%AF%E6%96%87/"},{"name":"教學文","slug":"教學文","permalink":"https://vince-chen-hao.github.io/tags/%E6%95%99%E5%AD%B8%E6%96%87/"}]}